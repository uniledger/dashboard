Directory Structure:
.
├── consolidated_code.txt
├── gather_code.sh
├── IMPROVEMENTS.md
├── package.json
├── package-lock.json
├── postcss.config.js
├── public
│   ├── favicon.ico
│   ├── favicon.svg
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── README.ARCHITECTURE.md
├── README.md
├── REFACTORING.md
├── remove-unused-files.txt
├── src
│   ├── App.css
│   ├── App.js
│   ├── components
│   │   ├── accounts
│   │   │   ├── AccountDetail.js
│   │   │   ├── AccountList.js
│   │   │   └── tables
│   │   │       └── AccountsTable.js
│   │   ├── analytics
│   │   │   └── AnalyticsView.js
│   │   ├── common
│   │   │   ├── ActionButton.js
│   │   │   ├── config
│   │   │   │   └── modelConfig.js
│   │   │   ├── DataTable.js
│   │   │   ├── DataTableSection.js
│   │   │   ├── DetailCard.js
│   │   │   ├── ErrorAlert.js
│   │   │   ├── FilterBadge.js
│   │   │   ├── GenericDetailView.js
│   │   │   ├── GenericListView.js
│   │   │   ├── index.js
│   │   │   ├── LoadingSpinner.js
│   │   │   ├── SectionHeader.js
│   │   │   └── StandardList.js
│   │   ├── dashboard
│   │   │   ├── AccountsByTypeView.js
│   │   │   ├── DashboardRouter.js
│   │   │   ├── DashboardView.js
│   │   │   └── layout
│   │   │       ├── DashboardFooter.js
│   │   │       └── DashboardHeader.js
│   │   ├── entities
│   │   │   ├── EntityDetail.js
│   │   │   └── EntityList.js
│   │   ├── events
│   │   │   └── EventEntryPage.js
│   │   ├── LedgerDashboard.js
│   │   ├── ledgers
│   │   │   ├── LedgerDetail.js
│   │   │   └── LedgerList.js
│   │   ├── processed-events
│   │   │   ├── ProcessedEventDetail.js
│   │   │   ├── ProcessedEventsList.js
│   │   │   └── ProcessedEventsView.js
│   │   ├── reference
│   │   │   ├── AccountCodesList.js
│   │   │   ├── CountriesList.js
│   │   │   └── CurrenciesList.js
│   │   ├── rules
│   │   │   ├── RuleDetail.js
│   │   │   ├── RulesList.js
│   │   │   └── RulesView.js
│   │   ├── shared
│   │   │   ├── DetailModal.js
│   │   │   ├── PageHeader.js
│   │   │   └── sidebar
│   │   │       ├── index.js
│   │   │       └── Sidebar.js
│   │   └── templates
│   │       ├── EventForm.js
│   │       ├── TemplateDetail.js
│   │       ├── TemplatesList.js
│   │       └── TemplatesPage.js
│   ├── config
│   │   └── api.js
│   ├── context
│   │   └── DashboardContext.js
│   ├── hooks
│   │   ├── useAccounts.js
│   │   ├── useDashboardData.js
│   │   ├── useDataFetching.js
│   │   ├── useEntities.js
│   │   ├── useLedgers.js
│   │   ├── useReferenceData.js
│   │   └── useTransactions.js
│   ├── index.css
│   ├── index.js
│   ├── reportWebVitals.js
│   ├── services
│   │   └── apiService.js
│   └── utils
│       ├── filterUtils
│       │   ├── accountFilters.js
│       │   ├── entityFilters.js
│       │   ├── index.js
│       │   └── ledgerFilters.js
│       ├── filterUtils.js
│       ├── formatters
│       │   ├── accountFormatters.js
│       │   ├── balanceFormatters.js
│       │   ├── dateFormatters.js
│       │   ├── entityFormatters.js
│       │   └── index.js
│       ├── formatters.js
│       └── useInterval.js
└── tailwind.config.js

27 directories, 90 files

File: ./package.json
--------------------
{
  "name": "ledgerrocket-dashboard",
  "version": "0.1.1",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.3.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "recharts": "^2.4.3",
    "uuid": "^9.0.0",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "tailwindcss": "^3.2.7",
    "autoprefixer": "^10.4.13",
    "postcss": "^8.4.21"
  }
}
File: ./postcss.config.js
--------------------
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
File: ./public/manifest.json
--------------------
{
  "short_name": "LedgerRocket",
  "name": "LedgerRocket Banking API Dashboard",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#1a365d",
  "background_color": "#ffffff"
}
File: ./src/reportWebVitals.js
--------------------
const reportWebVitals = (onPerfEntry) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
File: ./src/App.js
--------------------
import React, { useState } from 'react';
import LedgerDashboard from './components/LedgerDashboard';
import './App.css';

function App() {
  return (
    <div className="App">
      <LedgerDashboard />
    </div>
  );
}

export default App;
File: ./src/hooks/useDataFetching.js
--------------------
import { useState, useCallback } from 'react';

/**
 * Generic data fetching hook for reusable data operations
 * This hook reduces duplication across entity-specific hooks
 * 
 * @param {Object} options - Hook configuration options
 * @param {Function} options.fetchAll - Function to fetch all items
 * @param {Function} options.fetchById - Function to fetch item by ID
 * @param {Function} options.fetchChildren - Function to fetch child items
 * @param {Function} options.fetchSecondaryChildren - Optional function to fetch secondary children
 * @returns {Object} - Data and helper functions
 */
const useDataFetching = ({
  fetchAll,
  fetchById,
  fetchChildren,
  fetchSecondaryChildren = null,
}) => {
  // Primary data states
  const [items, setItems] = useState([]);
  const [selectedItem, setSelectedItem] = useState(null);
  
  // Children states
  const [childItems, setChildItems] = useState([]);
  const [secondaryChildItems, setSecondaryChildItems] = useState([]);
  
  // Loading and error states
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  /**
   * Fetch all items
   */
  const fetchAllItems = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await fetchAll();
      setItems(data);
      setLoading(false);
      return data;
    } catch (err) {
      console.error('Error fetching data:', err);
      setError(err.message || 'An error occurred while fetching data');
      setLoading(false);
      return null;
    }
  }, [fetchAll]);

  /**
   * Fetch item by ID with its children
   * @param {string|number} id - Item ID to fetch
   */
  const fetchItemById = useCallback(async (id) => {
    if (!id) return;
    
    setLoading(true);
    setError(null);
    
    try {
      // Fetch item details
      const itemData = await fetchById(id);
      setSelectedItem(itemData);
      
      // Fetch children for the item
      const childrenData = await fetchChildren(id);
      setChildItems(childrenData);
      
      // Fetch secondary children if function is provided
      let secondaryChildrenData = [];
      if (fetchSecondaryChildren) {
        secondaryChildrenData = await fetchSecondaryChildren(id);
        setSecondaryChildItems(secondaryChildrenData);
      }
      
      setLoading(false);
      
      // Return all fetched data
      const result = { 
        item: itemData, 
        children: childrenData
      };
      
      if (fetchSecondaryChildren) {
        result.secondaryChildren = secondaryChildrenData;
      }
      
      return result;
    } catch (err) {
      console.error('Error fetching item detail:', err);
      setError(err.message || 'An error occurred while fetching data');
      setLoading(false);
      return null;
    }
  }, [fetchById, fetchChildren, fetchSecondaryChildren]);

  /**
   * Refresh children for a specific item
   * @param {string|number} id - Item ID to refresh children for
   */
  const refreshChildren = useCallback(async (id) => {
    if (!id) return;
    
    try {
      const childrenData = await fetchChildren(id);
      setChildItems(childrenData);
      return childrenData;
    } catch (err) {
      console.error('Error refreshing children:', err);
      // Don't update error state on refresh to avoid disrupting the UI
      return null;
    }
  }, [fetchChildren]);

  /**
   * Refresh secondary children for a specific item
   * @param {string|number} id - Item ID to refresh secondary children for
   */
  const refreshSecondaryChildren = useCallback(async (id) => {
    if (!id || !fetchSecondaryChildren) return;
    
    try {
      const childrenData = await fetchSecondaryChildren(id);
      setSecondaryChildItems(childrenData);
      return childrenData;
    } catch (err) {
      console.error('Error refreshing secondary children:', err);
      // Don't update error state on refresh to avoid disrupting the UI
      return null;
    }
  }, [fetchSecondaryChildren]);

  /**
   * Clear the selected item and related data
   */
  const clearSelectedItem = useCallback(() => {
    setSelectedItem(null);
    setChildItems([]);
    setSecondaryChildItems([]);
  }, []);

  return {
    // Data
    items,
    selectedItem,
    childItems,
    secondaryChildItems,
    loading,
    error,
    
    // Actions
    fetchAllItems,
    fetchItemById,
    refreshChildren,
    refreshSecondaryChildren,
    clearSelectedItem,
    setSelectedItem,
    
    // Setters for direct state manipulation when needed
    setItems,
    setChildItems,
    setSecondaryChildItems
  };
};

export default useDataFetching;
File: ./src/hooks/useAccounts.js
--------------------
import { useState, useEffect, useCallback } from 'react';
import apiService from '../services/apiService';
import useDataFetching from './useDataFetching';

/**
 * Custom hook for managing accounts data, implementing the generic data fetching hook
 * @returns {Object} - Accounts data and helper functions
 */
const useAccounts = () => {
  // Define API-specific fetching functions
  const fetchAllAccounts = useCallback(() => {
    return apiService.account.getAccounts();
  }, []);
  
  const fetchAccountById = useCallback((accountId) => {
    return apiService.account.getAccountById(accountId);
  }, []);
  
  // Use the generic data fetching hook
  const {
    items: accounts,
    selectedItem: selectedAccount,
    loading,
    error,
    fetchAllItems: fetchAccounts,
    setSelectedItem: setSelectedAccount,
    clearSelectedItem: clearSelectedAccount,
    setItems: setAccounts
  } = useDataFetching({
    fetchAll: fetchAllAccounts,
    fetchById: fetchAccountById,
    fetchChildren: () => Promise.resolve([]) // Accounts don't have children
  });
  
  // Additional state for account-specific features
  const [filteredAccounts, setFilteredAccounts] = useState([]);
  const [filter, setFilter] = useState({
    active: false,
    type: ''
  });

  /**
   * Refresh account balances
   */
  const refreshAccountBalances = useCallback(async () => {
    try {
      const data = await fetchAllAccounts();
      setAccounts(data);
      applyFilter(data, filter);
      return true;
    } catch (err) {
      console.error('Error refreshing account balances:', err);
      return false;
    }
  }, [filter, fetchAllAccounts, setAccounts]);

  /**
   * Apply the current filter to accounts data
   * @param {Array} accountsData - Accounts data to filter
   * @param {Object} currentFilter - Current filter settings
   */
  const applyFilter = useCallback((accountsData, currentFilter) => {
    if (!currentFilter.active) {
      setFilteredAccounts(accountsData);
      return;
    }
    
    const filtered = accountsData.filter(account => {
      // Extract account type
      let accountType = 'OTHER';
      if (account.account_type) {
        accountType = account.account_type.toUpperCase();
      } else if (account.account_code && account.account_code.type) {
        accountType = account.account_code.type.toUpperCase();
      } else if (typeof account.account_code === 'object' && account.account_code.type) {
        accountType = account.account_code.type.toUpperCase();
      }
      
      return accountType === currentFilter.type;
    });
    
    setFilteredAccounts(filtered);
  }, []);

  /**
   * Filter accounts by type
   * @param {string} type - Account type to filter by
   */
  const filterByType = useCallback((type) => {
    const newFilter = {
      active: true,
      type: type.toUpperCase()
    };
    setFilter(newFilter);
    applyFilter(accounts, newFilter);
  }, [accounts, applyFilter]);

  /**
   * Clear the current filter
   */
  const clearFilter = useCallback(() => {
    const newFilter = {
      active: false,
      type: ''
    };
    setFilter(newFilter);
    applyFilter(accounts, newFilter);
  }, [accounts, applyFilter]);

  /**
   * Select an account by ID
   * @param {string|number} accountId - Account ID to select
   */
  const selectAccount = useCallback((accountId) => {
    const account = accounts.find(acc => 
      acc.account_id === accountId || 
      acc.account_id?.toString() === accountId?.toString() ||
      acc.account_extra_id === accountId || 
      acc.account_extra_id?.toString() === accountId?.toString()
    );
    setSelectedAccount(account);
  }, [accounts, setSelectedAccount]);

  // Apply filter whenever accounts or filter changes
  useEffect(() => {
    applyFilter(accounts, filter);
  }, [accounts, filter, applyFilter]);

  // Initial fetch
  useEffect(() => {
    fetchAccounts();
  }, [fetchAccounts]);

  return {
    // Data
    accounts,
    filteredAccounts,
    selectedAccount,
    filter,
    loading,
    error,
    
    // Actions
    fetchAccounts,
    refreshAccountBalances,
    filterByType,
    clearFilter,
    selectAccount,
    clearSelectedAccount
  };
};

export default useAccounts;
File: ./src/hooks/useEntities.js
--------------------
import { useCallback } from 'react';
import apiService from '../services/apiService';
import useDataFetching from './useDataFetching';

/**
 * Custom hook for managing entities data, implementing the generic data fetching hook
 * @returns {Object} - Entities data and helper functions
 */
const useEntities = () => {
  // Define API-specific fetching functions
  const fetchAllEntities = useCallback(() => {
    return apiService.entity.getEntities();
  }, []);
  
  const fetchEntityById = useCallback((entityId) => {
    return apiService.entity.getEntityById(entityId);
  }, []);
  
  const fetchEntityLedgers = useCallback((entityId) => {
    return apiService.entity.getEntityLedgers(entityId);
  }, []);
  
  const fetchEntityAccounts = useCallback((entityId) => {
    return apiService.entity.getEntityAccounts(entityId);
  }, []);
  
  // Use the generic data fetching hook
  const {
    items: entities,
    selectedItem: selectedEntity,
    childItems: entityLedgers,
    secondaryChildItems: entityAccounts,
    loading,
    error,
    fetchAllItems: fetchEntities,
    fetchItemById: fetchEntityWithDetails,
    refreshChildren: refreshEntityLedgers,
    refreshSecondaryChildren: refreshEntityAccounts,
    clearSelectedItem: clearSelectedEntity,
    setSelectedItem: setSelectedEntity
  } = useDataFetching({
    fetchAll: fetchAllEntities,
    fetchById: fetchEntityById,
    fetchChildren: fetchEntityLedgers,
    fetchSecondaryChildren: fetchEntityAccounts
  });
  
  return {
    // Data
    entities,
    selectedEntity,
    entityLedgers,
    entityAccounts,
    loading,
    error,
    
    // Actions
    fetchEntities,
    fetchEntityById: fetchEntityWithDetails,
    refreshEntityAccounts,
    clearSelectedEntity,
    setSelectedEntity
  };
};

export default useEntities;
File: ./src/hooks/useReferenceData.js
--------------------
import { useState, useEffect, useCallback } from 'react';
import apiService from '../services/apiService';

/**
 * Custom hook for managing reference data (currencies, countries, account codes)
 * @returns {Object} - Reference data and helper functions
 */
const useReferenceData = () => {
  // State for reference data
  const [currencies, setCurrencies] = useState([]);
  const [countries, setCountries] = useState([]);
  const [accountCodes, setAccountCodes] = useState([]);
  
  // Loading and error states
  const [loading, setLoading] = useState({
    currencies: false,
    countries: false,
    accountCodes: false
  });
  const [error, setError] = useState(null);

  /**
   * Fetch currencies
   */
  const fetchCurrencies = useCallback(async () => {
    setLoading(prev => ({ ...prev, currencies: true }));
    setError(null);
    
    try {
      const data = await apiService.reference.getCurrencies();
      setCurrencies(data);
      setLoading(prev => ({ ...prev, currencies: false }));
      return data;
    } catch (err) {
      console.error('Error fetching currencies:', err);
      setError(err.message || 'An error occurred while fetching currencies');
      setLoading(prev => ({ ...prev, currencies: false }));
      return null;
    }
  }, []);

  /**
   * Fetch countries
   */
  const fetchCountries = useCallback(async () => {
    setLoading(prev => ({ ...prev, countries: true }));
    setError(null);
    
    try {
      const data = await apiService.reference.getCountries();
      setCountries(data);
      setLoading(prev => ({ ...prev, countries: false }));
      return data;
    } catch (err) {
      console.error('Error fetching countries:', err);
      setError(err.message || 'An error occurred while fetching countries');
      setLoading(prev => ({ ...prev, countries: false }));
      return null;
    }
  }, []);

  /**
   * Fetch account codes
   */
  const fetchAccountCodes = useCallback(async () => {
    setLoading(prev => ({ ...prev, accountCodes: true }));
    setError(null);
    
    try {
      const data = await apiService.reference.getAccountCodes();
      setAccountCodes(data);
      setLoading(prev => ({ ...prev, accountCodes: false }));
      return data;
    } catch (err) {
      console.error('Error fetching account codes:', err);
      setError(err.message || 'An error occurred while fetching account codes');
      setLoading(prev => ({ ...prev, accountCodes: false }));
      return null;
    }
  }, []);

  /**
   * Check if any resource is currently loading
   */
  const isAnyLoading = loading.currencies || loading.countries || loading.accountCodes;

  return {
    // Data
    currencies,
    countries,
    accountCodes,
    loading,
    isAnyLoading,
    error,
    
    // Actions
    fetchCurrencies,
    fetchCountries,
    fetchAccountCodes
  };
};

export default useReferenceData;
File: ./src/hooks/useTransactions.js
--------------------
import { useState, useEffect, useCallback } from 'react';
import apiService from '../services/apiService';

/**
 * Custom hook for fetching and managing transactions data
 * @returns {Object} - Templates, events, and helper functions
 */
const useTransactions = () => {
  // Templates state
  const [templates, setTemplates] = useState([]);
  const [selectedTemplate, setSelectedTemplate] = useState(null);
  
  // Loading and error states
  const [loading, setLoading] = useState({
    templates: false,
    events: false,
    submission: false
  });
  
  const [error, setError] = useState({
    templates: null,
    events: null,
    submission: null
  });

  /**
   * Fetch all templates
   */
  const fetchTemplates = useCallback(async () => {
    setLoading(prev => ({ ...prev, templates: true }));
    setError(prev => ({ ...prev, templates: null }));
    
    try {
      const data = await apiService.transaction.getTemplates();
      setTemplates(data);
    } catch (err) {
      console.error('Error fetching templates:', err);
      setError(prev => ({ 
        ...prev, 
        templates: err.message || 'An error occurred while fetching templates'
      }));
    } finally {
      setLoading(prev => ({ ...prev, templates: false }));
    }
  }, []);

  /**
   * Select a template and set it as the selected template
   * @param {Object|string|number} templateOrId - Template object or ID to select
   */
  const selectTemplate = useCallback((templateOrId) => {
    if (!templateOrId) return;
    
    if (typeof templateOrId === 'object') {
      // If a template object was passed
      setSelectedTemplate(templateOrId);
    } else {
      // If a template ID was passed
      const template = templates.find(t => 
        t.template_id === templateOrId || 
        t.template_id?.toString() === templateOrId?.toString()
      );
      setSelectedTemplate(template);
    }
  }, [templates]);

  /**
   * Clear the selected template
   */
  const clearSelectedTemplate = useCallback(() => {
    setSelectedTemplate(null);
  }, []);

  /**
   * Submit an event based on a template
   * @param {Object} eventData - Event data to submit
   * @returns {Promise<Object>} - Response with status and transfer information
   */
  const submitEvent = useCallback(async (eventData) => {
    setLoading(prev => ({ ...prev, submission: true }));
    setError(prev => ({ ...prev, submission: null }));
    
    try {
      const response = await apiService.transaction.submitEvent(eventData);
      setLoading(prev => ({ ...prev, submission: false }));
      return response;
    } catch (err) {
      console.error('Error submitting event:', err);
      setError(prev => ({ 
        ...prev, 
        submission: err.message || 'An error occurred while submitting the event'
      }));
      throw err;
    }
  }, []);

  // Load templates when the component mounts
  useEffect(() => {
    fetchTemplates();
  }, [fetchTemplates]);

  return {
    // Data
    templates,
    selectedTemplate,
    loading,
    error,
    
    // Actions
    fetchTemplates,
    selectTemplate,
    clearSelectedTemplate,
    submitEvent
  };
};

export default useTransactions;
File: ./src/hooks/useLedgers.js
--------------------
import { useCallback } from 'react';
import apiService from '../services/apiService';
import useDataFetching from './useDataFetching';

/**
 * Custom hook for managing ledgers data, implementing the generic data fetching hook
 * @returns {Object} - Ledgers data and helper functions
 */
const useLedgers = () => {
  // Define API-specific fetching functions
  const fetchAllLedgers = useCallback(() => {
    return apiService.ledger.getLedgers();
  }, []);
  
  const fetchLedgerById = useCallback((ledgerId) => {
    return apiService.ledger.getLedgerById(ledgerId);
  }, []);
  
  const fetchLedgerAccounts = useCallback((ledgerId) => {
    return apiService.ledger.getLedgerAccounts(ledgerId);
  }, []);
  
  // Use the generic data fetching hook
  const {
    items: ledgers,
    selectedItem: selectedLedger,
    childItems: ledgerAccounts,
    loading,
    error,
    fetchAllItems: fetchLedgers,
    fetchItemById: fetchLedgerWithDetails,
    refreshChildren: refreshLedgerAccounts,
    clearSelectedItem: clearSelectedLedger,
    setSelectedItem: setSelectedLedger
  } = useDataFetching({
    fetchAll: fetchAllLedgers,
    fetchById: fetchLedgerById,
    fetchChildren: fetchLedgerAccounts
  });
  
  return {
    // Data
    ledgers,
    selectedLedger,
    ledgerAccounts,
    loading,
    error,
    
    // Actions
    fetchLedgers,
    fetchLedgerById: fetchLedgerWithDetails,
    refreshLedgerAccounts,
    clearSelectedLedger,
    setSelectedLedger
  };
};

export default useLedgers;
File: ./src/hooks/useDashboardData.js
--------------------
import { useState, useEffect, useCallback } from 'react';
import apiService from '../services/apiService';

/**
 * Custom hook for managing dashboard overview data
 * @returns {Object} - Dashboard data and helper functions
 */
const useDashboardData = () => {
  // State for dashboard data
  const [dashboardData, setDashboardData] = useState({
    entities: [],
    ledgers: [],
    accounts: []
  });
  
  // Loading and error states
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  /**
   * Fetch all dashboard data (entities, ledgers, accounts)
   */
  const fetchAllDashboardData = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Get data in parallel for better performance
      const [entitiesData, ledgersData, accountsData] = await Promise.all([
        apiService.entity.getEntities(),
        apiService.ledger.getLedgers(),
        apiService.account.getAccounts()
      ]);
      
      setDashboardData({
        entities: entitiesData,
        ledgers: ledgersData,
        accounts: accountsData
      });
      
      setLoading(false);
      return { entities: entitiesData, ledgers: ledgersData, accounts: accountsData };
    } catch (err) {
      console.error('Error fetching dashboard data:', err);
      setError(err.message || 'An error occurred while fetching dashboard data');
      setLoading(false);
      return null;
    }
  }, []);

  /**
   * Refresh only account balances
   */
  const refreshAccountBalances = useCallback(async () => {
    try {
      const accountsData = await apiService.account.getAccounts();
      
      setDashboardData(prev => ({
        ...prev,
        accounts: accountsData
      }));
      
      return accountsData;
    } catch (err) {
      console.error('Error refreshing account balances:', err);
      // Don't update error state on auto-refresh to avoid disrupting the UI
      return null;
    }
  }, []);

  return {
    // Data
    dashboardData,
    loading,
    error,
    
    // Actions
    fetchAllDashboardData,
    refreshAccountBalances
  };
};

export default useDashboardData;
File: ./src/context/DashboardContext.js
--------------------
import React, { createContext, useContext, useState } from 'react';

// Create Dashboard Context
const DashboardContext = createContext(null);

/**
 * Dashboard Context Provider
 * Manages shared state across dashboard components
 */
export const DashboardProvider = ({ children }) => {
  // Tab state
  const [activeTab, setActiveTab] = useState('dashboard');
  
  // Item selection state
  const [selectedEntityId, setSelectedEntityId] = useState(null);
  const [selectedLedgerId, setSelectedLedgerId] = useState(null);
  const [selectedAccountId, setSelectedAccountId] = useState(null);
  
  // Filter state
  const [accountsFilter, setAccountsFilter] = useState({
    active: false,
    type: ''
  });
  
  // Auto-refresh state
  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(true);
  const [refreshInterval, setRefreshInterval] = useState(10000); // 10 seconds
  
  // Detail modal state
  const [detailModal, setDetailModal] = useState({ 
    isOpen: false, 
    data: null, 
    title: '' 
  });
  
  // Global error state
  const [error, setError] = useState(null);
  
  // UI state
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  
  // Handle tab change
  const handleTabChange = (tab) => {
    console.log('Tab changed to:', tab);
    setActiveTab(tab);
    
    // Reset detail selections
    setSelectedEntityId(null);
    setSelectedLedgerId(null);
    setSelectedAccountId(null);
    
    // Reset accounts filter
    setAccountsFilter({
      active: false,
      type: ''
    });
  };
  
  // Handle entity selection
  const handleEntitySelection = (entityId) => {
    console.log('Entity selected:', entityId);
    // Set active tab to 'entities' to ensure we're in the right view
    setActiveTab('entities');
    // Reset other selections
    setSelectedLedgerId(null);
    setSelectedAccountId(null);
    // Set the selected entity
    setSelectedEntityId(entityId);
  };

  // Handle ledger selection
  const handleLedgerSelection = (ledgerId) => {
    console.log('Ledger selected:', ledgerId);
    // Set active tab to 'ledgers' to ensure we're in the right view
    setActiveTab('ledgers');
    // Reset other selections
    setSelectedEntityId(null);
    setSelectedAccountId(null);
    // Set the selected ledger
    setSelectedLedgerId(ledgerId);
  };
  
  // Handle account selection
  const handleAccountSelection = (accountId) => {
    // Set active tab to 'accounts' to ensure we're in the right view
    setActiveTab('accounts');
    // Reset other selections
    setSelectedEntityId(null);
    setSelectedLedgerId(null);
    // Set the selected account
    setSelectedAccountId(accountId);
  };
  
  // Handle drilling down to accounts by type
  const handleDrillToAccounts = (accountType) => {
    // Set the filter and change tab
    setAccountsFilter({
      active: true,
      type: accountType
    });
    setActiveTab('accounts');
  };

  // Handle opening the detail modal
  const handleViewJson = (data, title) => {
    setDetailModal({
      isOpen: true,
      data,
      title
    });
  };

  // Handle closing the detail modal
  const handleCloseModal = () => {
    setDetailModal({
      isOpen: false,
      data: null,
      title: ''
    });
  };
  
  // Context value
  const value = {
    // State
    activeTab,
    selectedEntityId,
    selectedLedgerId,
    selectedAccountId,
    accountsFilter,
    autoRefreshEnabled,
    refreshInterval,
    detailModal,
    error,
    sidebarCollapsed,
    
    // Actions
    setActiveTab,
    setSelectedEntityId,
    setSelectedLedgerId,
    setSelectedAccountId,
    setAccountsFilter,
    setAutoRefreshEnabled,
    setRefreshInterval,
    setDetailModal,
    setError,
    setSidebarCollapsed,
    
    // Handlers
    handleTabChange,
    handleEntitySelection,
    handleLedgerSelection,
    handleAccountSelection,
    handleDrillToAccounts,
    handleViewJson,
    handleCloseModal
  };
  
  return (
    <DashboardContext.Provider value={value}>
      {children}
    </DashboardContext.Provider>
  );
};

// Custom hook to use the dashboard context
export const useDashboard = () => {
  const context = useContext(DashboardContext);
  if (!context) {
    throw new Error('useDashboard must be used within a DashboardProvider');
  }
  return context;
};

export default DashboardContext;

File: ./src/config/api.js
--------------------
/**
 * API Configuration
 * Centralized configuration for API endpoints
 */

// Base URLs for the different APIs
export const LEDGER_API_BASE_URL = 'https://ledger.dev.ledgerrocket.com';
export const TRANSACTIONS_API_BASE_URL = 'https://transactions.dev.ledgerrocket.com';

// API Endpoints
export const endpoints = {
  // Ledger API endpoints
  ledger: {
    entities: `${LEDGER_API_BASE_URL}/api/v1/enriched-entities/`,
    entityById: (id) => `${LEDGER_API_BASE_URL}/api/v1/enriched-entities/${id}`,
    entityLedgers: (id) => `${LEDGER_API_BASE_URL}/api/v1/enriched-ledgers/?entity_id=${id}`,
    entityAccounts: (id) => `${LEDGER_API_BASE_URL}/api/v1/entities/${id}/enriched-accounts/`,
    
    ledgers: `${LEDGER_API_BASE_URL}/api/v1/enriched-ledgers/`,
    ledgerById: (id) => `${LEDGER_API_BASE_URL}/api/v1/enriched-ledgers/${id}`,
    ledgerAccounts: (id) => `${LEDGER_API_BASE_URL}/api/v1/ledgers/${id}/enriched-accounts/`,
    
    accounts: `${LEDGER_API_BASE_URL}/api/v1/enriched-accounts/`,
    accountById: (id) => `${LEDGER_API_BASE_URL}/api/v1/enriched-accounts/${id}`,
    
    currencies: `${LEDGER_API_BASE_URL}/api/v1/currencies/`,
    countries: `${LEDGER_API_BASE_URL}/api/v1/countries/`,
    accountCodes: `${LEDGER_API_BASE_URL}/api/v1/account-codes/`
  },
  
  // Transactions API endpoints
  transaction: {
    templates: `${TRANSACTIONS_API_BASE_URL}/api/v1/templates/`,
    processedEvents: `${TRANSACTIONS_API_BASE_URL}/api/v1/processed-events/`,
    rules: `${TRANSACTIONS_API_BASE_URL}/api/v1/rules/`,
    submitEvent: `${TRANSACTIONS_API_BASE_URL}/api/v1/events/`
  }
};

export default {
  LEDGER_API_BASE_URL,
  TRANSACTIONS_API_BASE_URL,
  endpoints
};
File: ./src/services/apiService.js
--------------------
/**
 * API Service for Uniledger Dashboard
 * Centralizes all API calls to maintain consistency and reduce duplication
 */

import { endpoints } from '../config/api';

/**
 * Generic fetch wrapper with error handling
 * @param {string} url - The URL to fetch
 * @param {Object} options - Fetch options
 * @returns {Promise<Object>} - The response data
 */
const fetchWithErrorHandling = async (url, options = {}) => {
  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      // Get the raw response text
      const errorText = await response.text();
      throw new Error(errorText);
    }
    
    return await response.json();
  } catch (error) {
    console.error(`Fetch error for ${url}:`, error);
    throw error;
  }
};

/**
 * Helper to ensure IDs are properly formatted for API calls
 * @param {string|number|Object} id - The ID to format
 * @returns {string} - Formatted ID
 */
const ensureIdString = (id) => {
  if (id === null || id === undefined) {
    console.error('Invalid ID provided:', id);
    throw new Error('Invalid ID provided');
  }
  
  if (typeof id === 'object') {
    // If we accidentally got passed an object, try to extract the ID
    if (id.ledger_id) return id.ledger_id.toString();
    if (id.entity_id) return id.entity_id.toString();
    if (id.account_id) return id.account_id.toString();
    
    console.error('Object passed instead of ID:', id);
    throw new Error('Invalid object passed instead of ID');
  }
  
  return id.toString();
};

/**
 * Entity-related API calls
 */
const entityApi = {
  /**
   * Get all entities
   * @returns {Promise<Array>} - List of entities
   */
  getEntities: () => 
    fetchWithErrorHandling(endpoints.ledger.entities),
  
  /**
   * Get a specific entity by ID
   * @param {string|number} entityId - Entity ID
   * @returns {Promise<Object>} - Entity data
   */
  getEntityById: (entityId) => 
    fetchWithErrorHandling(endpoints.ledger.entityById(ensureIdString(entityId))),
  
  /**
   * Get all ledgers for a specific entity
   * @param {string|number} entityId - Entity ID
   * @returns {Promise<Array>} - List of ledgers for the entity
   */
  getEntityLedgers: (entityId) => 
    fetchWithErrorHandling(endpoints.ledger.entityLedgers(ensureIdString(entityId))),
  
  /**
   * Get all accounts for a specific entity
   * @param {string|number} entityId - Entity ID
   * @returns {Promise<Array>} - List of accounts for the entity
   */
  getEntityAccounts: (entityId) => 
    fetchWithErrorHandling(endpoints.ledger.entityAccounts(ensureIdString(entityId)))
};

/**
 * Ledger-related API calls
 */
const ledgerApi = {
  /**
   * Get all ledgers
   * @returns {Promise<Array>} - List of ledgers
   */
  getLedgers: () => 
    fetchWithErrorHandling(endpoints.ledger.ledgers),
  
  /**
   * Get a specific ledger by ID
   * @param {string|number} ledgerId - Ledger ID
   * @returns {Promise<Object>} - Ledger data
   */
  getLedgerById: (ledgerId) => 
    fetchWithErrorHandling(endpoints.ledger.ledgerById(ensureIdString(ledgerId))),
  
  /**
   * Get all accounts for a specific ledger
   * @param {string|number} ledgerId - Ledger ID
   * @returns {Promise<Array>} - List of accounts for the ledger
   */
  getLedgerAccounts: (ledgerId) => 
    fetchWithErrorHandling(endpoints.ledger.ledgerAccounts(ensureIdString(ledgerId)))
};

/**
 * Account-related API calls
 */
const accountApi = {
  /**
   * Get all accounts
   * @returns {Promise<Array>} - List of accounts
   */
  getAccounts: () => 
    fetchWithErrorHandling(endpoints.ledger.accounts),
  
  /**
   * Get a specific account by ID
   * @param {string|number} accountId - Account ID
   * @returns {Promise<Object>} - Account data
   */
  getAccountById: (accountId) => 
    fetchWithErrorHandling(endpoints.ledger.accountById(ensureIdString(accountId)))
};

/**
 * Reference data API calls
 */
const referenceApi = {
  /**
   * Get all currencies
   * @returns {Promise<Array>} - List of currencies
   */
  getCurrencies: () => 
    fetchWithErrorHandling(endpoints.ledger.currencies),
  
  /**
   * Get all countries
   * @returns {Promise<Array>} - List of countries
   */
  getCountries: () => 
    fetchWithErrorHandling(endpoints.ledger.countries),
  
  /**
   * Get all account codes
   * @returns {Promise<Array>} - List of account codes
   */
  getAccountCodes: () => 
    fetchWithErrorHandling(endpoints.ledger.accountCodes)
};

/**
 * Transaction-related API calls
 */
const transactionApi = {
  /**
   * Get all templates
   * @returns {Promise<Array>} - List of templates
   */
  getTemplates: () => 
    fetchWithErrorHandling(endpoints.transaction.templates),
  
  /**
   * Get all processed events
   * @returns {Promise<Array>} - List of processed events
   */
  getProcessedEvents: () => 
    fetchWithErrorHandling(endpoints.transaction.processedEvents),
  
  /**
   * Get all rules
   * @returns {Promise<Array>} - List of rules
   */
  getRules: () => 
    fetchWithErrorHandling(endpoints.transaction.rules),
  
  /**
   * Submit an event based on a template
   * @param {Object} eventData - Event data
   * @returns {Promise<Object>} - Response with status and transfer information
   */
  submitEvent: (eventData) => {
    return fetchWithErrorHandling(endpoints.transaction.submitEvent, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(eventData),
    });
  }
};

// Export all API services
const apiService = {
  entity: entityApi,
  ledger: ledgerApi,
  account: accountApi,
  reference: referenceApi,
  transaction: transactionApi,
};

export default apiService;
File: ./src/utils/formatters.js
--------------------
/**
 * Utility functions for consistent data formatting across the dashboard
 */

/**
 * Format account balance using correct scale from currency
 * @param {number} balance - The raw balance value (integer)
 * @param {object} currency - Currency object with scale information
 * @param {boolean} showDecimal - Whether to show the decimal places
 * @param {string} currencySymbol - Optional currency symbol to prepend
 * @returns {string} Formatted balance value
 */
export const formatBalance = (balance, currency, showDecimal = true, currencySymbol = '') => {
  if (typeof balance !== 'number') return 'N/A';
  
  // Get the scale (decimal places) from the currency
  let scale = 2; // Default scale
  
  if (currency) {
    if (typeof currency.scale === 'number') {
      scale = currency.scale;
    } else if (currency.r_currency && typeof currency.r_currency.scale === 'number') {
      scale = currency.r_currency.scale;
    }
  }
  
  // Convert to decimal value
  const decimalValue = balance / Math.pow(10, scale);
  
  // Format with correct number of decimal places
  let formattedValue;
  if (showDecimal) {
    // Fixed decimal places
    formattedValue = decimalValue.toFixed(scale);
  } else {
    // Just round to whole number
    formattedValue = Math.round(decimalValue).toString();
  }
  
  // Add commas as thousands separators
  formattedValue = formattedValue.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  
  // Handle negative numbers with parentheses
  if (decimalValue < 0) {
    // Remove minus sign and add parentheses
    return `${currencySymbol}(${formattedValue.replace('-', '')})`;
  } else {
    return `${currencySymbol}${formattedValue}`;
  }
};

/**
 * Get CSS class for balance display
 * @param {number} balance - The balance value
 * @returns {string} - CSS class name for balance display
 */
export const getBalanceClass = (balance) => {
  if (typeof balance !== 'number') return '';
  return balance < 0 ? 'text-red-600 text-right font-medium' : 'text-gray-900 text-right font-medium';
};

/**
 * Get a readable display of country information
 * @param {object} item - The item (entity, ledger) with country info
 * @param {object} entity - Optional entity context for ledgers
 * @returns {string} Formatted country display
 */
export const getCountryDisplay = (item, entity) => {
  if (!item) return 'N/A';
  
  // Format function for country objects
  const formatCountryObj = (country) => {
    if (country && country.name && country.country_code) {
      return `${country.name} (${country.country_code})`;
    }
    return null;
  };
  
  // First check if r_entity has country info
  if (item.r_entity && item.r_entity.r_country) {
    return formatCountryObj(item.r_entity.r_country) || 'N/A';
  }
  
  // Check for direct r_country attribute
  if (item.r_country) {
    return formatCountryObj(item.r_country) || 'N/A';
  }
  
  // Check if it's a ledger that belongs to an entity with a country
  if (entity && entity.r_country) {
    return formatCountryObj(entity.r_country) || 'N/A';
  }
  
  // Check entity fields
  if (item.entity && item.entity.r_country) {
    return formatCountryObj(item.entity.r_country) || 'N/A';
  }
  
  // For ledgers with country_code 'NA', use the entity's country
  if (item.country_code === 'NA' && entity && entity.r_country) {
    return formatCountryObj(entity.r_country) || entity.country_code || 'N/A';
  }
  
  // Try to find country by traversing various paths in the object
  const paths = [
    'enriched_entity.r_country',
    'enriched_ledger.r_entity.r_country',
    'enriched_ledger.r_country',
    'r_entity.r_country'
  ];
  
  for (const path of paths) {
    const parts = path.split('.');
    let obj = item;
    let valid = true;
    
    for (const part of parts) {
      if (!obj || !obj[part]) {
        valid = false;
        break;
      }
      obj = obj[part];
    }
    
    if (valid && obj.name && obj.country_code) {
      return formatCountryObj(obj) || 'N/A';
    }
  }
  
  // Return country code if available
  if (item.country_code && item.country_code !== 'NA') {
    return item.country_code;
  }
  
  // Return any country field
  if (item.country) {
    return item.country;
  }
  
  // Try entity property if available
  if (item.r_entity?.country_code && item.r_entity.country_code !== 'NA') {
    return item.r_entity.country_code;
  }
  
  if (item.entity?.country_code && item.entity.country_code !== 'NA') {
    return item.entity.country_code;
  }
  
  return 'N/A';
};

/**
 * Format account code for display
 * @param {object|string} accountCode - Account code object or string
 * @returns {string} Formatted account code
 */
export const formatAccountCode = (accountCode) => {
  if (!accountCode) return 'N/A';
  
  // Handle when account_code is a full object
  if (typeof accountCode === 'object') {
    return `${accountCode.account_code} - ${accountCode.name || ''}`;
  }
  
  // Handle when it's just the code value
  return accountCode;
};

/**
 * Get the account type description from an account object
 * @param {object} account - Account object
 * @returns {string} Account type description
 */
export const getAccountType = (account) => {
  if (!account) return 'N/A';
  
  // Try different possible paths to get account type
  if (account.account_type) {
    return account.account_type;
  }
  
  if (account.type) {
    return account.type;
  }
  
  if (account.account_code && account.account_code.type) {
    return account.account_code.type;
  }
  
  if (typeof account.account_code === 'object' && account.account_code.type) {
    return account.account_code.type;
  }
  
  if (account.code && account.code.type) {
    return account.code.type;
  }
  
  return 'Unknown';
};

/**
 * Get currency info from an account or ledger
 * @param {object} item - Account or ledger object
 * @returns {object|null} - Currency object or null if not found
 */
export const getCurrencyInfo = (item) => {
  if (!item) return null;
  
  // Try to find currency in various locations
  if (item.r_currency) {
    return item.r_currency;
  }
  
  if (item.currency) {
    return item.currency;
  }
  
  if (item.enriched_ledger && item.enriched_ledger.r_currency) {
    return item.enriched_ledger.r_currency;
  }
  
  if (item.ledger && item.ledger.r_currency) {
    return item.ledger.r_currency;
  }
  
  // Return a simple object with the currency code if available
  if (item.currency_code) {
    return { currency_code: item.currency_code, scale: 2 };
  }
  
  return null;
};

/**
 * Format a date for display
 * @param {number|string|Date} timestamp - The timestamp or date to format
 * @param {boolean} includeTime - Whether to include the time in the formatted date
 * @returns {string} Formatted date string
 */
export const formatDate = (timestamp, includeTime = false) => {
  if (!timestamp) return 'N/A';
  
  let date;
  
  // Handle Unix timestamps (seconds since epoch)
  if (typeof timestamp === 'number') {
    // Check if it's in seconds (10 digits) or milliseconds (13 digits)
    if (timestamp < 10000000000) {
      // Convert from seconds to milliseconds
      date = new Date(timestamp * 1000);
    } else {
      date = new Date(timestamp);
    }
  } else if (typeof timestamp === 'string') {
    // Try to parse as ISO date or Unix timestamp
    if (!isNaN(Number(timestamp))) {
      const num = Number(timestamp);
      if (num < 10000000000) {
        date = new Date(num * 1000);
      } else {
        date = new Date(num);
      }
    } else {
      date = new Date(timestamp);
    }
  } else if (timestamp instanceof Date) {
    date = timestamp;
  } else {
    return 'N/A';
  }
  
  // Check if the date is valid
  if (isNaN(date.getTime())) {
    return 'N/A';
  }
  
  // Format the date
  const options = {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  };
  
  if (includeTime) {
    options.hour = '2-digit';
    options.minute = '2-digit';
    options.second = '2-digit';
  }
  
  return date.toLocaleString('en-US', options);
};

/**
 * Get a display name for an account
 * @param {object} account - Account object
 * @returns {string} Account display name
 */
export const getAccountDisplayName = (account) => {
  return account.name || 'N/A';
};
File: ./src/utils/formatters/balanceFormatters.js
--------------------
/**
 * Balance and currency formatting utilities
 */

/**
 * Format account balance using correct scale from currency
 * @param {number} balance - The raw balance value (integer)
 * @param {object} currency - Currency object with scale information
 * @param {boolean} showDecimal - Whether to show the decimal places
 * @param {string} currencySymbol - Optional currency symbol to prepend
 * @returns {string} Formatted balance value
 */
export const formatBalance = (balance, currency, showDecimal = true, currencySymbol = '') => {
  if (typeof balance !== 'number') return 'N/A';
  
  // Get the scale (decimal places) from the currency
  let scale = 2; // Default scale
  
  if (currency) {
    if (typeof currency.scale === 'number') {
      scale = currency.scale;
    } else if (currency.r_currency && typeof currency.r_currency.scale === 'number') {
      scale = currency.r_currency.scale;
    }
  }
  
  // Convert to decimal value
  const decimalValue = balance / Math.pow(10, scale);
  
  // Format with correct number of decimal places
  let formattedValue;
  if (showDecimal) {
    // Fixed decimal places
    formattedValue = decimalValue.toFixed(scale);
  } else {
    // Just round to whole number
    formattedValue = Math.round(decimalValue).toString();
  }
  
  // Add commas as thousands separators
  formattedValue = formattedValue.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  
  // Handle negative numbers with parentheses
  if (decimalValue < 0) {
    // Remove minus sign and add parentheses
    return `${currencySymbol}(${formattedValue.replace('-', '')})`;
  } else {
    return `${currencySymbol}${formattedValue}`;
  }
};

/**
 * Get CSS class for balance display
 * @param {number} balance - The balance value
 * @returns {string} - CSS class name for balance display
 */
export const getBalanceClass = (balance) => {
  if (typeof balance !== 'number') return '';
  return balance < 0 ? 'text-red-600 text-right font-medium' : 'text-gray-900 text-right font-medium';
};

/**
 * Get currency info from an account or ledger
 * @param {object} item - Account or ledger object
 * @returns {object|null} - Currency object or null if not found
 */
export const getCurrencyInfo = (item) => {
  if (!item) return null;
  
  // Try to find currency in various locations
  if (item.r_currency) {
    return item.r_currency;
  }
  
  if (item.currency) {
    return item.currency;
  }
  
  if (item.enriched_ledger && item.enriched_ledger.r_currency) {
    return item.enriched_ledger.r_currency;
  }
  
  if (item.ledger && item.ledger.r_currency) {
    return item.ledger.r_currency;
  }
  
  // Return a simple object with the currency code if available
  if (item.currency_code) {
    return { currency_code: item.currency_code, scale: 2 };
  }
  
  return null;
};
File: ./src/utils/formatters/entityFormatters.js
--------------------
/**
 * Entity and country formatting utilities
 */

/**
 * Get a readable display of country information
 * @param {object} item - The item (entity, ledger) with country info
 * @param {object} entity - Optional entity context for ledgers
 * @returns {string} Formatted country display
 */
export const getCountryDisplay = (item, entity) => {
  if (!item) return 'N/A';
  
  // Format function for country objects
  const formatCountryObj = (country) => {
    if (country && country.name && country.country_code) {
      return `${country.name} (${country.country_code})`;
    }
    return null;
  };
  
  // First check if r_entity has country info
  if (item.r_entity && item.r_entity.r_country) {
    return formatCountryObj(item.r_entity.r_country) || 'N/A';
  }
  
  // Check for direct r_country attribute
  if (item.r_country) {
    return formatCountryObj(item.r_country) || 'N/A';
  }
  
  // Check if it's a ledger that belongs to an entity with a country
  if (entity && entity.r_country) {
    return formatCountryObj(entity.r_country) || 'N/A';
  }
  
  // Check entity fields
  if (item.entity && item.entity.r_country) {
    return formatCountryObj(item.entity.r_country) || 'N/A';
  }
  
  // For ledgers with country_code 'NA', use the entity's country
  if (item.country_code === 'NA' && entity && entity.r_country) {
    return formatCountryObj(entity.r_country) || entity.country_code || 'N/A';
  }
  
  // Try to find country by traversing various paths in the object
  const paths = [
    'enriched_entity.r_country',
    'enriched_ledger.r_entity.r_country',
    'enriched_ledger.r_country',
    'r_entity.r_country'
  ];
  
  for (const path of paths) {
    const parts = path.split('.');
    let obj = item;
    let valid = true;
    
    for (const part of parts) {
      if (!obj || !obj[part]) {
        valid = false;
        break;
      }
      obj = obj[part];
    }
    
    if (valid && obj.name && obj.country_code) {
      return formatCountryObj(obj) || 'N/A';
    }
  }
  
  // Return country code if available
  if (item.country_code && item.country_code !== 'NA') {
    return item.country_code;
  }
  
  // Return any country field
  if (item.country) {
    return item.country;
  }
  
  // Try entity property if available
  if (item.r_entity?.country_code && item.r_entity.country_code !== 'NA') {
    return item.r_entity.country_code;
  }
  
  if (item.entity?.country_code && item.entity.country_code !== 'NA') {
    return item.entity.country_code;
  }
  
  return 'N/A';
};
File: ./src/utils/formatters/accountFormatters.js
--------------------
/**
 * Account-specific formatting utilities
 */

/**
 * Format account code for display
 * @param {object|string} accountCode - Account code object or string
 * @returns {string} Formatted account code
 */
export const formatAccountCode = (accountCode) => {
  if (!accountCode) return 'N/A';
  
  // Handle when account_code is a full object
  if (typeof accountCode === 'object') {
    return `${accountCode.account_code} - ${accountCode.name || ''}`;
  }
  
  // Handle when it's just the code value
  return accountCode;
};

/**
 * Get the account type description from an account object
 * @param {object} account - Account object
 * @returns {string} Account type description
 */
export const getAccountType = (account) => {
  if (!account) return 'N/A';
  
  // Try different possible paths to get account type
  if (account.account_type) {
    return account.account_type;
  }
  
  if (account.type) {
    return account.type;
  }
  
  if (account.account_code && account.account_code.type) {
    return account.account_code.type;
  }
  
  if (typeof account.account_code === 'object' && account.account_code.type) {
    return account.account_code.type;
  }
  
  if (account.code && account.code.type) {
    return account.code.type;
  }
  
  return 'Unknown';
};

/**
 * Get a display name for an account
 * @param {object} account - Account object
 * @returns {string} Account display name
 */
export const getAccountDisplayName = (account) => {
  return account.name || 'N/A';
};
File: ./src/utils/formatters/dateFormatters.js
--------------------
/**
 * Date formatting utilities
 */

/**
 * Format a date for display
 * @param {number|string|Date} timestamp - The timestamp or date to format
 * @param {boolean} includeTime - Whether to include the time in the formatted date
 * @returns {string} Formatted date string
 */
export const formatDate = (timestamp, includeTime = false) => {
  if (!timestamp) return 'N/A';
  
  let date;
  
  // Handle Unix timestamps (seconds since epoch)
  if (typeof timestamp === 'number') {
    // Check if it's in seconds (10 digits) or milliseconds (13 digits)
    if (timestamp < 10000000000) {
      // Convert from seconds to milliseconds
      date = new Date(timestamp * 1000);
    } else {
      date = new Date(timestamp);
    }
  } else if (typeof timestamp === 'string') {
    // Try to parse as ISO date or Unix timestamp
    if (!isNaN(Number(timestamp))) {
      const num = Number(timestamp);
      if (num < 10000000000) {
        date = new Date(num * 1000);
      } else {
        date = new Date(num);
      }
    } else {
      date = new Date(timestamp);
    }
  } else if (timestamp instanceof Date) {
    date = timestamp;
  } else {
    return 'N/A';
  }
  
  // Check if the date is valid
  if (isNaN(date.getTime())) {
    return 'N/A';
  }
  
  // Format the date
  const options = {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  };
  
  if (includeTime) {
    options.hour = '2-digit';
    options.minute = '2-digit';
    options.second = '2-digit';
  }
  
  return date.toLocaleString('en-US', options);
};
File: ./src/utils/formatters/index.js
--------------------
/**
 * Central export file for all formatter modules
 */
export * from './balanceFormatters';
export * from './dateFormatters';
export * from './accountFormatters';
export * from './entityFormatters';
File: ./src/utils/filterUtils.js
--------------------
/**
 * This file is maintained for backwards compatibility.
 * Please use the modular filterUtils directory for new code.
 */

import filterUtilsImport, {
  filterData,
  searchData,
  getSearchFields,
  filterByModelType,
  accountFilters,
  entityFilters,
  ledgerFilters
} from './filterUtils/index';

// Re-export the filterAccountsByType function directly
export const filterAccountsByType = (accounts, accountType) => {
  if (!accountType) {
    return accounts;
  }

  const normalizedType = accountType.toUpperCase();

  return accounts.filter(account => {
    // Extract account type from different possible structures
    let accountTypeValue = 'OTHER';
    
    if (account.account_type) {
      accountTypeValue = account.account_type.toUpperCase();
    } else if (account.account_code && account.account_code.type) {
      accountTypeValue = account.account_code.type.toUpperCase();
    } else if (typeof account.account_code === 'object' && account.account_code.type) {
      accountTypeValue = account.account_code.type.toUpperCase();
    } else if (account.type) {
      accountTypeValue = account.type.toUpperCase();
    }
    
    return accountTypeValue === normalizedType;
  });
};

// Create a filterUtils object with all the functions
export const filterUtils = {
  filterData,
  searchData,
  getSearchFields,
  filterByModelType,
  filterAccountsByType, // Add this directly to filterUtils
  ...accountFilters,
  ...entityFilters,
  ...ledgerFilters
};

// Export default for direct imports
export default {
  ...filterUtilsImport,
  filterAccountsByType
};
File: ./src/utils/filterUtils/index.js
--------------------
/**
 * Enhanced filtering utilities with centralized filtering logic
 */

import { accountFilters } from './accountFilters';
import { entityFilters } from './entityFilters';
import { ledgerFilters } from './ledgerFilters';

/**
 * Generic filter function that can filter data by any field and value
 * @param {Array} data - The data array to filter
 * @param {Object} filter - Filter configuration { field, value, exact }
 * @returns {Array} - Filtered data array
 */
export const filterData = (data, filter) => {
  if (!filter || !filter.field || filter.value === undefined || filter.value === null) {
    return data;
  }

  return data.filter(item => {
    // Get the value from the item, supporting nested fields with dot notation
    const fields = filter.field.split('.');
    let itemValue = item;
    
    for (const field of fields) {
      if (itemValue === null || itemValue === undefined) {
        return false;
      }
      itemValue = itemValue[field];
    }

    // Handle exact matching vs. includes matching
    if (filter.exact) {
      // Exact matching (case insensitive for strings)
      if (typeof itemValue === 'string' && typeof filter.value === 'string') {
        return itemValue.toLowerCase() === filter.value.toLowerCase();
      }
      return itemValue === filter.value;
    } else {
      // Includes matching
      if (typeof itemValue === 'string' && typeof filter.value === 'string') {
        return itemValue.toLowerCase().includes(filter.value.toLowerCase());
      } else if (itemValue !== null && itemValue !== undefined) {
        // For non-string values, convert to string and check includes
        return itemValue.toString().includes(filter.value.toString());
      }
      return false;
    }
  });
};

/**
 * Search through an array of objects for matching text
 * @param {Array} data - The data array to search
 * @param {string} searchQuery - The search query
 * @param {Array} searchFields - Optional array of specific fields to search (defaults to all fields)
 * @returns {Array} - Filtered data array
 */
export const searchData = (data, searchQuery, searchFields = null) => {
  if (!searchQuery) {
    return data;
  }

  const normalizedQuery = searchQuery.toLowerCase();

  return data.filter(item => {
    // If searchFields is provided, only search those fields
    if (searchFields && searchFields.length > 0) {
      return searchFields.some(field => {
        const fieldParts = field.split('.');
        let value = item;
        
        // Handle nested fields
        for (const part of fieldParts) {
          if (!value || typeof value !== 'object') return false;
          value = value[part];
        }
        
        if (typeof value === 'string') {
          return value.toLowerCase().includes(normalizedQuery);
        } else if (typeof value === 'number') {
          return value.toString().includes(normalizedQuery);
        }
        return false;
      });
    }
    
    // Otherwise, search all string and number properties (first level only)
    return Object.entries(item).some(([_, value]) => {
      if (typeof value === 'string') {
        return value.toLowerCase().includes(normalizedQuery);
      } else if (typeof value === 'number') {
        return value.toString().includes(normalizedQuery);
      }
      return false;
    });
  });
};

/**
 * Get common search fields for a model type
 * @param {string} modelType - Type of model ('entity', 'ledger', 'account', etc.)
 * @returns {Array} - Array of field names to search
 */
export const getSearchFields = (modelType) => {
  const searchFieldsMap = {
    entity: ['name', 'entity_id', 'type', 'country_code', 'description'],
    ledger: ['name', 'ledger_id', 'r_entity.name', 'country_code', 'description'],
    account: ['name', 'account_id', 'account_code', 'account_type', 'description'],
    template: ['name', 'template_id', 'product', 'description'],
    processedEvent: ['processed_event_id', 'status', 'description', 'template.name'],
    rule: ['name', 'rule_id', 'type', 'status', 'description']
  };
  
  return searchFieldsMap[modelType] || [];
};

/**
 * Filter data using the appropriate model-specific filter
 * @param {Array} data - The data array to filter
 * @param {Object} filter - Filter configuration object
 * @param {string} modelType - Type of model ('entity', 'ledger', 'account', etc.)
 * @returns {Array} - Filtered data array
 */
export const filterByModelType = (data, filter, modelType) => {
  if (!filter || !modelType) {
    return data;
  }
  
  switch (modelType) {
    case 'account':
      return accountFilters.applyFilters(data, filter);
    case 'entity':
      return entityFilters.applyFilters(data, filter);
    case 'ledger':
      return ledgerFilters.applyFilters(data, filter);
    default:
      // Fall back to generic filtering
      return filterData(data, filter);
  }
};

// Export account filters from accountFilters.js
export { accountFilters } from './accountFilters';

// Export entity filters from entityFilters.js
export { entityFilters } from './entityFilters';

// Export ledger filters from ledgerFilters.js
export { ledgerFilters } from './ledgerFilters';

// Export all filter utilities
export default {
  filterData,
  searchData,
  getSearchFields,
  filterByModelType,
  accountFilters,
  entityFilters,
  ledgerFilters
};
File: ./src/utils/filterUtils/entityFilters.js
--------------------
/**
 * Entity-specific filtering logic
 */
import { filterData } from './index';

/**
 * Filter entities by country
 * @param {Array} entities - Array of entity objects
 * @param {string} countryCode - Country code to filter by
 * @returns {Array} - Filtered entities
 */
export const filterEntitiesByCountry = (entities, countryCode) => {
  if (!countryCode) {
    return entities;
  }
  
  const normalizedCode = countryCode.toUpperCase();
  
  return entities.filter(entity => {
    // Check direct country code
    if (entity.country_code && entity.country_code.toUpperCase() === normalizedCode) {
      return true;
    }
    
    // Check through r_country
    if (entity.r_country && entity.r_country.country_code && 
        entity.r_country.country_code.toUpperCase() === normalizedCode) {
      return true;
    }
    
    return false;
  });
};

/**
 * Filter entities by type
 * @param {Array} entities - Array of entity objects
 * @param {string} entityType - Entity type to filter by
 * @returns {Array} - Filtered entities
 */
export const filterEntitiesByType = (entities, entityType) => {
  if (!entityType) {
    return entities;
  }
  
  const normalizedType = entityType.toUpperCase();
  
  return entities.filter(entity => {
    const type = (entity.type || entity.entity_type || '').toUpperCase();
    return type === normalizedType;
  });
};

/**
 * Apply all entity filters
 * @param {Array} entities - Array of entity objects
 * @param {Object} filters - All filters to apply
 * @returns {Array} - Filtered entities
 */
export const applyEntityFilters = (entities, filters) => {
  let filteredEntities = [...entities];
  
  // Apply country filter if specified
  if (filters.countryCode) {
    filteredEntities = filterEntitiesByCountry(filteredEntities, filters.countryCode);
  }
  
  // Apply type filter if specified
  if (filters.entityType) {
    filteredEntities = filterEntitiesByType(filteredEntities, filters.entityType);
  }
  
  // Apply any other generic filters
  if (filters.field && filters.value) {
    filteredEntities = filterData(filteredEntities, filters);
  }
  
  return filteredEntities;
};

// Export entity filters
export const entityFilters = {
  filterByCountry: filterEntitiesByCountry,
  filterByType: filterEntitiesByType,
  applyFilters: applyEntityFilters
};
File: ./src/utils/filterUtils/ledgerFilters.js
--------------------
/**
 * Ledger-specific filtering logic
 */
import { filterData } from './index';

/**
 * Filter ledgers by entity
 * @param {Array} ledgers - Array of ledger objects
 * @param {string|number} entityId - Entity ID to filter by
 * @returns {Array} - Filtered ledgers
 */
export const filterLedgersByEntity = (ledgers, entityId) => {
  if (!entityId) {
    return ledgers;
  }
  
  const idStr = entityId.toString();
  
  return ledgers.filter(ledger => {
    // Check r_entity.entity_id
    if (ledger.r_entity && ledger.r_entity.entity_id) {
      return ledger.r_entity.entity_id.toString() === idStr;
    }
    
    // Check entity.entity_id
    if (ledger.entity && ledger.entity.entity_id) {
      return ledger.entity.entity_id.toString() === idStr;
    }
    
    // Check entity_id directly
    if (ledger.entity_id) {
      return ledger.entity_id.toString() === idStr;
    }
    
    return false;
  });
};

/**
 * Filter ledgers by currency
 * @param {Array} ledgers - Array of ledger objects
 * @param {string} currencyCode - Currency code to filter by
 * @returns {Array} - Filtered ledgers
 */
export const filterLedgersByCurrency = (ledgers, currencyCode) => {
  if (!currencyCode) {
    return ledgers;
  }
  
  const normalizedCode = currencyCode.toUpperCase();
  
  return ledgers.filter(ledger => {
    // Check r_currency.currency_code
    if (ledger.r_currency && ledger.r_currency.currency_code) {
      return ledger.r_currency.currency_code.toUpperCase() === normalizedCode;
    }
    
    // Check currency_code directly
    if (ledger.currency_code) {
      return ledger.currency_code.toUpperCase() === normalizedCode;
    }
    
    return false;
  });
};

/**
 * Apply all ledger filters
 * @param {Array} ledgers - Array of ledger objects
 * @param {Object} filters - All filters to apply
 * @returns {Array} - Filtered ledgers
 */
export const applyLedgerFilters = (ledgers, filters) => {
  let filteredLedgers = [...ledgers];
  
  // Apply entity filter if specified
  if (filters.entityId) {
    filteredLedgers = filterLedgersByEntity(filteredLedgers, filters.entityId);
  }
  
  // Apply currency filter if specified
  if (filters.currencyCode) {
    filteredLedgers = filterLedgersByCurrency(filteredLedgers, filters.currencyCode);
  }
  
  // Apply country filter if specified
  if (filters.countryCode) {
    filteredLedgers = filterData(filteredLedgers, {
      field: 'r_country.country_code',
      value: filters.countryCode,
      exact: true
    });
  }
  
  // Apply any other generic filters
  if (filters.field && filters.value) {
    filteredLedgers = filterData(filteredLedgers, filters);
  }
  
  return filteredLedgers;
};

// Export ledger filters
export const ledgerFilters = {
  filterByEntity: filterLedgersByEntity,
  filterByCurrency: filterLedgersByCurrency,
  applyFilters: applyLedgerFilters
};
File: ./src/utils/filterUtils/accountFilters.js
--------------------
/**
 * Account-specific filtering logic
 */
import { filterData } from './index';

/**
 * Filter account data by account type (handles different structures)
 * @param {Array} accounts - Array of account objects
 * @param {string} accountType - Account type to filter by
 * @returns {Array} - Filtered accounts
 */
export const filterAccountsByType = (accounts, accountType) => {
  if (!accountType) {
    return accounts;
  }

  const normalizedType = accountType.toUpperCase();

  return accounts.filter(account => {
    // Extract account type from different possible structures
    let accountTypeValue = 'OTHER';
    
    if (account.account_type) {
      accountTypeValue = account.account_type.toUpperCase();
    } else if (account.account_code && account.account_code.type) {
      accountTypeValue = account.account_code.type.toUpperCase();
    } else if (typeof account.account_code === 'object' && account.account_code.type) {
      accountTypeValue = account.account_code.type.toUpperCase();
    } else if (account.type) {
      accountTypeValue = account.type.toUpperCase();
    }
    
    return accountTypeValue === normalizedType;
  });
};

/**
 * Filter accounts by balance range
 * @param {Array} accounts - Array of account objects
 * @param {Object} balanceFilter - Balance filter { min, max }
 * @returns {Array} - Filtered accounts
 */
export const filterAccountsByBalance = (accounts, balanceFilter) => {
  if (!balanceFilter || (balanceFilter.min === undefined && balanceFilter.max === undefined)) {
    return accounts;
  }
  
  return accounts.filter(account => {
    const balance = account.balance;
    if (typeof balance !== 'number') return false;
    
    if (balanceFilter.min !== undefined && balanceFilter.max !== undefined) {
      return balance >= balanceFilter.min && balance <= balanceFilter.max;
    } else if (balanceFilter.min !== undefined) {
      return balance >= balanceFilter.min;
    } else if (balanceFilter.max !== undefined) {
      return balance <= balanceFilter.max;
    }
    
    return true;
  });
};

/**
 * Apply all account filters
 * @param {Array} accounts - Array of account objects
 * @param {Object} filters - All filters to apply
 * @returns {Array} - Filtered accounts
 */
export const applyAccountFilters = (accounts, filters) => {
  let filteredAccounts = [...accounts];
  
  // Apply type filter if specified
  if (filters.type) {
    filteredAccounts = filterAccountsByType(filteredAccounts, filters.type);
  }
  
  // Apply ledger filter if specified
  if (filters.ledgerId) {
    filteredAccounts = filterData(filteredAccounts, {
      field: 'enriched_ledger.ledger_id',
      value: filters.ledgerId,
      exact: true
    });
  }
  
  // Apply entity filter if specified
  if (filters.entityId) {
    filteredAccounts = filterData(filteredAccounts, {
      field: 'enriched_ledger.r_entity.entity_id',
      value: filters.entityId,
      exact: true
    });
  }
  
  // Apply balance filter if specified
  if (filters.balance) {
    filteredAccounts = filterAccountsByBalance(filteredAccounts, filters.balance);
  }
  
  // Apply any other generic filters
  if (filters.field && filters.value) {
    filteredAccounts = filterData(filteredAccounts, filters);
  }
  
  return filteredAccounts;
};

// Export account filters
export const accountFilters = {
  filterByType: filterAccountsByType,
  filterByBalance: filterAccountsByBalance,
  applyFilters: applyAccountFilters
};
File: ./src/utils/useInterval.js
--------------------
import { useEffect, useRef } from 'react';

/**
 * Custom hook that calls a function repeatedly at a specified interval
 * @param {Function} callback Function to call 
 * @param {number} delay Time in ms, null to pause
 */
function useInterval(callback, delay) {
  const savedCallback = useRef();

  // Remember the latest callback
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // Set up the interval
  useEffect(() => {
    function tick() {
      savedCallback.current();
    }
    if (delay !== null) {
      const id = setInterval(tick, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
}

export default useInterval;
File: ./src/components/accounts/AccountDetail.js
--------------------
import React from 'react';
import { GenericDetailView, AccountConfig } from '../common';

/**
 * Account Detail component using GenericDetailView
 */
const AccountDetail = ({ 
  account, 
  onViewJson, 
  onBack, 
  onRefresh, 
  onViewEntity, 
  onViewLedger 
}) => {
  // Extract entity and ledger information
  const entity = account?.entity || account?.enriched_entity || 
    (account?.enriched_ledger && account?.enriched_ledger.entity);
    
  const ledger = account?.ledger || account?.enriched_ledger;
  
  // Create entity and ledger link sections if available
  const entitySection = entity ? {
    label: 'Entity',
    content: (
      <button 
        className="text-blue-600 hover:text-blue-800 hover:underline"
        onClick={() => entity.entity_id && onViewEntity && onViewEntity(entity.entity_id)}
      >
        {entity.name || entity.entity_id}
      </button>
    )
  } : null;
  
  const ledgerSection = ledger ? {
    label: 'Ledger',
    content: (
      <button 
        className="text-blue-600 hover:text-blue-800 hover:underline"
        onClick={() => ledger.ledger_id && onViewLedger && onViewLedger(ledger.ledger_id)}
      >
        {ledger.name || ledger.ledger_id}
      </button>
    )
  } : null;

  // Get standard sections from model config
  let sections = account ? [...AccountConfig.detailSections(account, entity, ledger)] : [];
  
  // Add creation info if available
  if (account?.date_created) {
    sections.push({
      label: 'Created',
      content: new Date(account.date_created).toLocaleString()
    });
  }
  
  // Add entity and ledger link sections if available
  if (entitySection) {
    // Insert entity section after account type (index 3)
    sections.splice(3, 0, entitySection);
  }
  
  if (ledgerSection) {
    // Insert ledger section after entity section or after account type
    const insertIndex = entitySection ? 4 : 3;
    sections.splice(insertIndex, 0, ledgerSection);
  }
  
  // Use GenericDetailView for consistent presentation
  return (
    <GenericDetailView
      data={account}
      title={AccountConfig.title + " Detail"}
      subtitle={account?.name}
      sections={sections}
      onBack={onBack}
      onRefresh={onRefresh}
      onViewJson={onViewJson}
      loadingMessage="Loading account details..."
    />
  );
};

export default AccountDetail;
File: ./src/components/accounts/AccountList.js
--------------------
import React, { useState, useEffect } from 'react';
import { GenericListView, AccountConfig, FilterBadge } from '../common';
import { formatBalance, formatAccountCode, getBalanceClass, getCurrencyInfo } from '../../utils/formatters';
import apiService from '../../services/apiService';

/**
 * Account List component using GenericListView
 */
const AccountList = ({ 
  accounts, 
  accountTypeFilter, 
  onViewJson, 
  onRefresh, 
  onViewEntity, 
  onViewLedger, 
  onViewAccount, 
  onClearFilter 
}) => {
  const [entities, setEntities] = useState([]);
  const [ledgers, setLedgers] = useState([]);
  const [loading, setLoading] = useState(false);

  // Fetch entity and ledger data for display and drilldown
  useEffect(() => {
    const fetchReferenceData = async () => {
      setLoading(true);
      try {
        // Fetch entities
        const entitiesData = await apiService.entity.getEntities();
        setEntities(entitiesData);
        
        // Fetch ledgers
        const ledgersData = await apiService.ledger.getLedgers();
        setLedgers(ledgersData);
      } catch (err) {
        console.error('Error fetching reference data:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchReferenceData();
  }, []);

  // Helper function to find entity for an account
  const getEntityForAccount = (account) => {
    // Get entity ID from account or its ledger
    const entityId = account.entity_id || 
      (account.enriched_ledger && account.enriched_ledger.entity_id) ||
      (account.entity && account.entity.entity_id);
    
    if (!entityId) {
      return null;
    }
    
    // Find entity in our fetched list
    const foundEntity = entities.find(e => e.entity_id === entityId);
    return foundEntity;
  };
  
  const getLedgerForAccount = (account) => {
    // Get ledger ID directly
    const ledgerId = account.ledger_id || 
      (account.enriched_ledger && account.enriched_ledger.ledger_id);
    
    if (!ledgerId) return null;
    
    // Find ledger in our fetched list
    return ledgers.find(l => l.ledger_id === ledgerId);
  };

  const getCurrencyCode = (account) => {
    return (account.enriched_ledger && account.enriched_ledger.r_currency && account.enriched_ledger.r_currency.currency_code) || 
      account.currency_code || 
      'N/A';
  };

  // Define columns for the DataTable - start with the base AccountConfig columns
  const columns = [...AccountConfig.listColumns];
  
  // Add entity column
  columns.push({
    key: 'entity',
    header: 'Account Owner',
    render: (account) => {
      const entity = getEntityForAccount(account);
      return entity ? entity.name : (account.entity ? account.entity.name : 'N/A');
    },
    cellClassName: (account) => {
      const entityId = getEntityForAccount(account)?.entity_id || 
                       account.entity_id || 
                       (account.enriched_ledger && account.enriched_ledger.entity_id) || 
                       (account.entity && account.entity.entity_id);
      return entityId ? 'text-blue-600 cursor-pointer hover:underline' : 'text-gray-500';
    },
    onClick: (account) => {
      const entityId = getEntityForAccount(account)?.entity_id || 
                       account.entity_id || 
                       (account.enriched_ledger && account.enriched_ledger.entity_id) || 
                       (account.entity && account.entity.entity_id);
      if (entityId && onViewEntity) {
        onViewEntity(entityId);
        return true; // Prevent other click handlers
      }
      return false;
    },
    preventRowClick: true
  });

  // Add ledger column
  columns.push({
    key: 'ledger',
    header: 'Ledger',
    render: (account) => {
      const ledger = getLedgerForAccount(account);
      return ledger ? ledger.name : (account.enriched_ledger?.name || account.ledger?.name || account.ledger_name || 'N/A');
    },
    cellClassName: (account) => {
      const ledgerId = getLedgerForAccount(account)?.ledger_id || 
                       account.ledger_id || 
                       (account.enriched_ledger && account.enriched_ledger.ledger_id);
      return ledgerId ? 'text-blue-600 cursor-pointer hover:underline' : 'text-gray-500';
    },
    onClick: (account) => {
      const ledgerId = getLedgerForAccount(account)?.ledger_id || 
                       account.ledger_id || 
                       (account.enriched_ledger && account.enriched_ledger.ledger_id);
      if (ledgerId && onViewLedger) {
        onViewLedger(ledgerId);
        return true; // Prevent other click handlers
      }
      return false;
    },
    preventRowClick: true
  });

  // Add currency column
  columns.push({
    key: 'currency',
    header: 'Currency',
    render: (account) => getCurrencyCode(account)
  });

  // Make sure balance column is using consistent formatting
  const balanceColumnIndex = columns.findIndex(col => col.key === 'balance');
  if (balanceColumnIndex !== -1) {
    columns[balanceColumnIndex] = {
      ...columns[balanceColumnIndex],
      cellClassName: (account) => getBalanceClass(account.balance),
      render: (account) => {
        const currency = getCurrencyInfo(account);
        return formatBalance(account.balance, currency, true);
      }
    };
  }

  // Create filter object for GenericListView if filtering by account type
  const filter = accountTypeFilter ? {
    field: 'account_type',
    value: accountTypeFilter,
    label: 'Account Type'
  } : null;

  // Custom header component with filter badge if filtering is active
  const customHeader = accountTypeFilter ? (
    <div className="mb-4">
      <FilterBadge
        label={`Account Type: ${accountTypeFilter}`}
        onClear={onClearFilter}
        count={accounts.length}
        entityName="account"
      />
    </div>
  ) : null;

  return (
    <GenericListView
      data={accounts}
      columns={columns}
      title="Accounts"
      idField="account_id"
      loading={loading}
      onItemClick={(item) => onViewAccount ? onViewAccount(item) : null}
      onViewJson={onViewJson}
      onRefresh={onRefresh}
      filter={filter}
      onClearFilter={onClearFilter}
      searchPlaceholder="Search accounts..."
      emptyMessage="No accounts found"
      customHeader={customHeader}
    />
  );
};

export default AccountList;
File: ./src/components/accounts/tables/AccountsTable.js
--------------------
import React from 'react';
import { formatBalance, formatAccountCode, getAccountType } from '../../../utils/formatters';

/**
 * Reusable accounts table component for displaying a list of accounts
 * 
 * @param {Object} props Component props
 * @param {Array} props.accounts List of accounts to display
 * @param {Function} props.onViewAccount Function to handle viewing an account
 * @param {Function} props.onViewLedger Function to handle viewing a ledger
 * @param {Function} props.onViewEntity Function to handle viewing an entity
 * @param {Function} props.onViewJson Function to handle viewing JSON data
 * @param {Object} props.currency Optional currency object for formatting balances
 * @param {string} props.emptyMessage Message to display when no accounts are found
 * @param {boolean} props.showLedger Whether to show the ledger column
 * @param {boolean} props.showEntity Whether to show the entity column
 */
const AccountsTable = ({ 
  accounts = [], 
  onViewAccount,
  onViewLedger,
  onViewEntity,
  onViewJson,
  currency,
  emptyMessage = "No accounts found",
  showLedger = true,
  showEntity = true
}) => {
  // Helper function for account codes
  const getAccountCodeDisplay = (account) => {
    return formatAccountCode(account.account_code || account.code);
  };
  
  // Helper function to find entity for an account
  const getEntityForAccount = (account) => {
    // Get entity from any available source
    return account.entity || 
      account.enriched_entity || 
      (account.enriched_ledger && account.enriched_ledger.entity);
  };
  
  // Helper function to get ledger for an account
  const getLedgerForAccount = (account) => {
    return account.ledger || account.enriched_ledger;
  };
  
  // Sort accounts by account code
  const sortedAccounts = [...accounts].sort((a, b) => {
    // Extract account code from account_code or name
    const getCode = (account) => {
      if (account.account_code && typeof account.account_code === 'object') {
        return String(account.account_code.account_code || '');
      } else if (typeof account.account_code === 'string') {
        return account.account_code;
      } else if (account.name && account.name.includes('-')) {
        return account.name.split('-')[0].trim();
      }
      return '';
    };
    const codeA = getCode(a);
    const codeB = getCode(b);
    return (codeA || '').toString().localeCompare((codeB || '').toString());
  });
  
  return (
    <div className="bg-white rounded-lg shadow overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Account Code</th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
            {showEntity && (
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                {showLedger ? 'Owner' : 'Entity'}
              </th>
            )}
            {showLedger && (
              <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ledger</th>
            )}
            <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Balance</th>
            <th className="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {sortedAccounts && sortedAccounts.length > 0 ? sortedAccounts.map(account => {
            const entity = getEntityForAccount(account);
            const ledger = getLedgerForAccount(account);
            const accountCurrency = currency || 
              (ledger && ledger.r_currency) || 
              account.currency;
            
            return (
              <tr key={account.account_id || account.account_extra_id} className="hover:bg-gray-50">
                <td 
                  className="px-6 py-4 whitespace-nowrap text-sm text-blue-600 cursor-pointer hover:underline"
                  onClick={() => onViewAccount && onViewAccount(account)}
                >
                  {account.account_id || account.account_extra_id || 'N/A'}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                  {account.name || 'N/A'}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {getAccountCodeDisplay(account)}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {getAccountType(account)}
                </td>
                {showEntity && entity && (
                  <td 
                    className="px-6 py-4 whitespace-nowrap text-sm text-blue-600 cursor-pointer hover:underline"
                    onClick={() => onViewEntity && entity.entity_id && onViewEntity(entity.entity_id)}
                  >
                    {entity.name || entity.entity_id || 'N/A'}
                  </td>
                )}
                {showLedger && ledger && (
                  <td 
                    className="px-6 py-4 whitespace-nowrap text-sm text-blue-600 cursor-pointer hover:underline"
                    onClick={() => onViewLedger && ledger.ledger_id && onViewLedger(ledger.ledger_id)}
                  >
                    {ledger.name || ledger.ledger_id || 'N/A'}
                  </td>
                )}
                <td className="px-6 py-4 whitespace-nowrap text-sm text-right font-medium">
                  {typeof account.balance === 'number' ? (
                    <span className={account.balance < 0 ? 'text-red-600' : 'text-gray-900'}>
                      {formatBalance(account.balance, accountCurrency, true)}
                    </span>
                  ) : 'N/A'}
                </td>
                <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">
                  <button 
                    className="text-gray-600 hover:text-gray-800"
                    onClick={() => onViewJson && onViewJson(account, `Account: ${account.name || 'N/A'}`)}
                  >
                    JSON
                  </button>
                </td>
              </tr>
            );
          }) : (
            <tr>
              <td colSpan={showLedger && showEntity ? 8 : (showLedger || showEntity ? 7 : 6)} className="px-6 py-4 text-center text-sm text-gray-500">
                {emptyMessage}
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
};

export default AccountsTable;
File: ./src/components/LedgerDashboard.js
--------------------
import React from 'react';
import { DashboardProvider } from '../context/DashboardContext';
import Sidebar from './shared/sidebar';
import DashboardRouter from './dashboard/DashboardRouter';
import DashboardHeader from './dashboard/layout/DashboardHeader';
import DashboardFooter from './dashboard/layout/DashboardFooter';
import { useDashboard } from '../context/DashboardContext';

/**
 * Dashboard layout component that provides the overall structure
 * with sidebar, header, content area, and footer
 */
const DashboardLayout = ({ children }) => {
  const { activeTab, sidebarCollapsed, setSidebarCollapsed, handleTabChange } = useDashboard();
  
  return (
    <div className="min-h-screen bg-gray-50 flex">
      {/* Sidebar Navigation */}
      <Sidebar 
        activeTab={activeTab} 
        onTabChange={handleTabChange} 
        collapsed={sidebarCollapsed} 
        setCollapsed={setSidebarCollapsed}
      />
      
      {/* Main Content Area */}
      <div className="flex-1 flex flex-col overflow-hidden">
        <DashboardHeader />
        {children}
        <DashboardFooter />
      </div>
    </div>
  );
};

/**
 * Main dashboard component that manages navigation and data flow
 * Provides context via DashboardProvider
 */
const LedgerDashboard = () => {
  return (
    <DashboardProvider>
      <DashboardLayout>
        <DashboardRouter />
      </DashboardLayout>
    </DashboardProvider>
  );
};

export default LedgerDashboard;
File: ./src/components/templates/TemplateDetail.js
--------------------
import React from 'react';
import { GenericDetailView, ActionButton, TemplateConfig } from '../common';

/**
 * Template Detail component using GenericDetailView
 */
const TemplateDetail = ({ template, onBack, onViewJson, onUseTemplate }) => {
  // Get all sections from the template configuration
  const sections = TemplateConfig.getAllSections(template);
  
  // Custom actions for the detail card
  const customActions = (
    <>
      <ActionButton
        variant="outline"
        onClick={() => onViewJson(template, `Template ${template.template_id}`)}
      >
        View JSON
      </ActionButton>
      <ActionButton
        variant="primary"
        onClick={() => onUseTemplate(template)}
      >
        Use This Template
      </ActionButton>
      <ActionButton
        variant="secondary"
        onClick={onBack}
      >
        Back
      </ActionButton>
    </>
  );

  return (
    <GenericDetailView
      data={template}
      title="Template Detail"
      subtitle={template?.name}
      sections={sections}
      onBack={onBack}
      onRefresh={null} // Templates don't need refreshing
      onViewJson={onViewJson}
      customActions={customActions}
    />
  );
};

export default TemplateDetail;
File: ./src/components/templates/TemplatesPage.js
--------------------
import React, { useState, useEffect } from 'react';
import useTransactions from '../../hooks/useTransactions';
import useAccounts from '../../hooks/useAccounts';
import TemplatesList from './TemplatesList';
import TemplateDetail from './TemplateDetail';
import EventForm from './EventForm';
import apiService from '../../services/apiService';

/**
 * Main Templates page component
 * Manages whether to show the list, detail, or event form view
 */
const TemplatesPage = ({ onViewJson }) => {
  const { 
    templates,
    selectedTemplate,
    fetchTemplates,
    submitEvent,
    clearSelectedTemplate,
    selectTemplate,
    loading
  } = useTransactions();

  const {
    accounts,
    fetchAccounts
  } = useAccounts();

  const [view, setView] = useState('list'); // 'list', 'detail', or 'event-form'
  const [ledgers, setLedgers] = useState([]);
  const [loadingLedgers, setLoadingLedgers] = useState(false);

  // Update the view when selectedTemplate changes
  useEffect(() => {
    if (selectedTemplate && view === 'list') {
      setView('detail');
    } else if (!selectedTemplate && view !== 'list') {
      setView('list');
    }
  }, [selectedTemplate, view]);

  // Fetch ledgers when needed
  useEffect(() => {
    if (view === 'event-form') {
      fetchLedgers();
      fetchAccounts();
    }
  }, [view, fetchAccounts]);

  const fetchLedgers = async () => {
    setLoadingLedgers(true);
    try {
      const data = await apiService.ledger.getLedgers();
      setLedgers(data);
    } catch (error) {
      console.error('Error fetching ledgers:', error);
    } finally {
      setLoadingLedgers(false);
    }
  };

  const handleViewJson = (data, title) => {
    if (onViewJson) {
      onViewJson(data, title);
    }
  };

  const handleUseTemplate = () => {
    setView('event-form');
  };

  const handleBackToList = () => {
    clearSelectedTemplate();
    setView('list');
  };

  const handleBackToDetail = () => {
    setView('detail');
  };

  const handleSelectTemplate = (template) => {
    selectTemplate(template);
    setView('detail');
  };

  // Determine which view to show based on state
  if (view === 'event-form' && selectedTemplate) {
    return (
      <EventForm 
        template={selectedTemplate}
        ledgers={ledgers}
        accounts={accounts}
        onBack={handleBackToDetail}
        onViewJson={handleViewJson}
        onSubmitEvent={submitEvent}
      />
    );
  }

  if ((view === 'detail' || selectedTemplate) && view !== 'event-form') {
    return (
      <TemplateDetail 
        template={selectedTemplate}
        onViewJson={handleViewJson}
        onUseTemplate={handleUseTemplate}
        onBack={handleBackToList}
      />
    );
  }

  return (
    <TemplatesList 
      templates={templates}
      onViewJson={handleViewJson}
      onSelectTemplate={handleSelectTemplate}
      onRefresh={fetchTemplates}
      loading={loading.templates}
    />
  );
};

export default TemplatesPage;
File: ./src/components/templates/EventForm.js
--------------------
import React, { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid'; // You may need to add this dependency

/**
 * Component for creating and submitting events based on templates
 */
const EventForm = ({ template, ledgers, accounts, onBack, onSubmitEvent, onViewJson }) => {
  // Helper function to get the ledger ID for a transfer
  const getLedgerId = (transfer) => {
    // Try all possible property paths where ledger ID might be found
    return transfer.ledger_id || 
           transfer.ledgerId || 
           transfer.ledger?.ledger_id || 
           transfer.ledger || 
           // Fall back to the event's ledger ID if available
           eventData.ledger_id;
  };

  // Helper function to format IDs properly (especially for uint128 values)
  const formatId = (id) => {
    if (id === undefined || id === null) return 'N/A';
    
    // Check if it's a string already
    if (typeof id === 'string') return id;
    
    // If it's a number in scientific notation (like 8.954231552487467e+37)
    // try to convert it to a full string representation
    try {
      // Convert to string first to handle scientific notation correctly
      const idStr = id.toString();
      
      // Check if it's in scientific notation
      if (idStr.includes('e+')) {
        // Use BigInt for accurate conversion of large integers
        if (typeof BigInt !== 'undefined') {
          // For scientific notation, we need to convert it manually
          const [mantissa, exponent] = idStr.split('e+');
          const mantissaInt = parseFloat(mantissa);
          const exponentInt = parseInt(exponent, 10);
          
          // Create a string with the correct number of digits
          const mantissaStr = mantissaInt.toString().replace('.', '');
          const zerosToAdd = exponentInt - (mantissaStr.length - 1);
          return mantissaStr + '0'.repeat(Math.max(0, zerosToAdd));
        }
      }
      
      // For regular numbers, just use toString
      return idStr;
    } catch (err) {
      console.warn('Error formatting ID:', err);
      return id.toString();
    }
  };
  // Extract accounts that are allowed based on the template constraints
  // For now, we'll just use all accounts since we don't have specific constraints
  
  const [eventData, setEventData] = useState({
    event_id: uuidv4(),
    template_id: template ? template.template_id : '',
    ledger_id: '',
    amount: '',
    accounts: {},
    metadata: {}
  });
  
  const [metadataFields, setMetadataFields] = useState([{ key: '', value: '' }]);
  const [eventResponse, setEventResponse] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Update template_id when the template changes
  useEffect(() => {
    if (template) {
      setEventData(prev => ({
        ...prev,
        template_id: template.template_id
      }));
    }
  }, [template]);
  
  // Helper to get required account keys from template
  const getRequiredAccountKeys = () => {
    if (!template) return [];
    
    // Analyze the template legs to find account references
    const accountKeys = new Set();
    
    template.legs.forEach(leg => {
      // Check if the debit_account contains an accounts reference
      const debitMatch = leg.debit_account.match(/accounts\['([^']+)'\]/);
      if (debitMatch) {
        accountKeys.add(debitMatch[1]);
      }
      
      // Check if the credit_account contains an accounts reference
      const creditMatch = leg.credit_account.match(/accounts\['([^']+)'\]/);
      if (creditMatch) {
        accountKeys.add(creditMatch[1]);
      }
    });
    
    return Array.from(accountKeys);
  };
  
  const accountKeys = getRequiredAccountKeys();
  
  const handleAccountChange = (key, accountId) => {
    setEventData(prev => ({
      ...prev,
      accounts: {
        ...prev.accounts,
        [key]: accountId
      }
    }));
  };
  
  const handleMetadataKeyChange = (index, key) => {
    const updatedFields = [...metadataFields];
    updatedFields[index].key = key;
    setMetadataFields(updatedFields);
    updateMetadataState(updatedFields);
  };
  
  const handleMetadataValueChange = (index, value) => {
    const updatedFields = [...metadataFields];
    updatedFields[index].value = value;
    setMetadataFields(updatedFields);
    updateMetadataState(updatedFields);
  };
  
  const addMetadataField = () => {
    setMetadataFields([...metadataFields, { key: '', value: '' }]);
  };
  
  const removeMetadataField = (index) => {
    const updatedFields = metadataFields.filter((_, i) => i !== index);
    setMetadataFields(updatedFields);
    updateMetadataState(updatedFields);
  };
  
  const updateMetadataState = (fields) => {
    const metadata = {};
    fields.forEach(field => {
      if (field.key.trim() !== '' && field.value.trim() !== '') {
        metadata[field.key] = field.value;
      }
    });
    
    setEventData(prev => ({
      ...prev,
      metadata
    }));
  };
  
  const isFormValid = () => {
    return (
      eventData.event_id.trim() !== '' &&
      eventData.template_id !== '' &&
      eventData.ledger_id !== '' &&
      eventData.amount !== '' &&
      accountKeys.every(key => eventData.accounts[key] !== undefined)
    );
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!isFormValid()) {
      setError('Please fill out all required fields');
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Add product type from template
      const eventDataToSubmit = {
        ...eventData,
        amount: parseInt(eventData.amount),
        product: template.product, // Include product from template
        metadata: {
          ...eventData.metadata,
          original_event_json: JSON.stringify(eventData)
        }
      };
      
      const response = await onSubmitEvent(eventDataToSubmit);
      setEventResponse(response);
      setIsLoading(false);
    } catch (err) {
      setError(err.message || 'An error occurred while submitting the event');
      setIsLoading(false);
    }
  };
  
  const resetForm = () => {
    setEventData({
      event_id: uuidv4(),
      template_id: template ? template.template_id : '',
      ledger_id: '',
      amount: '',
      accounts: {},
      metadata: {}
    });
    setMetadataFields([{ key: '', value: '' }]);
    setEventResponse(null);
    setError(null);
  };
  
  if (!template) {
    return (
      <div className="bg-white shadow sm:rounded-lg p-6">
        <div className="text-center">
          <p className="text-gray-500">Please select a template first</p>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white shadow sm:rounded-lg">
      <div className="px-4 py-5 sm:p-6">
        <h3 className="text-lg leading-6 font-medium text-gray-900">
          Create Event using Template: {template.name}
        </h3>
        <div className="mt-2 max-w-xl text-sm text-gray-500">
          <p>{template.description}</p>
        </div>
        
        {/* Show response if we have one */}
        {eventResponse && (
          <div className="mt-4 p-4 border rounded-md bg-gray-50">
            <div className="flex justify-between items-start">
            <div className="flex items-center space-x-4">
              <h4 className="text-md font-medium text-gray-900">Event Response</h4>
            <button
              type="button"
              onClick={() => onViewJson && onViewJson(eventData, 'Original Event JSON')}
                className="text-sm text-blue-600 hover:text-blue-500 px-2 py-1 border border-blue-200 rounded"
            >
                View Event JSON
                </button>
                </div>
                <button
                  type="button"
                  onClick={resetForm}
                  className="text-sm text-blue-600 hover:text-blue-500"
                >
                  Create Another Event
                </button>
              </div>
            <div className="mt-2">
              <p className="text-sm text-gray-600">Status: {eventResponse.status}</p>
              
              {eventResponse.transfers && eventResponse.transfers.length > 0 && (
                <div className="mt-3">
                  <h5 className="text-sm font-medium text-gray-900">Generated Transfers:</h5>
                  <div className="mt-2 overflow-x-auto">
                    <table className="min-w-full divide-y divide-gray-200">
                      <thead className="bg-gray-50">
                        <tr>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ledger ID</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">From</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">To</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Code</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                        </tr>
                      </thead>
                      <tbody className="bg-white divide-y divide-gray-200">
                        {eventResponse.transfers.map((transfer, index) => (
                          <tr key={index}>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatId(transfer.id)}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatId(getLedgerId(transfer))}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatId(transfer.debit_account_id)}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{formatId(transfer.credit_account_id)}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{transfer.amount}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{transfer.code}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-blue-600 hover:text-blue-800 cursor-pointer">
                              <button
                                onClick={() => onViewJson && onViewJson(transfer, `Transfer: ${formatId(transfer.id)}`)}
                                className="text-blue-500 hover:text-blue-700"
                              >
                                View JSON
                              </button>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}
              
              {eventResponse.errors && eventResponse.errors.length > 0 && (
                <div className="mt-3">
                  <h5 className="text-sm font-medium text-red-600">Errors:</h5>
                  <ul className="mt-2 list-disc pl-5 space-y-1">
                    {eventResponse.errors.map((error, index) => (
                      <li key={index} className="text-sm text-red-600">{error}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          </div>
        )}
        
        {/* Show form if we don't have a response yet */}
        {!eventResponse && (
          <form onSubmit={handleSubmit} className="mt-5 space-y-6">
            {/* Event ID */}
            <div>
              <label htmlFor="event_id" className="block text-sm font-medium text-gray-700">
                Event ID (UUID)
              </label>
              <div className="mt-1">
                <input
                  type="text"
                  name="event_id"
                  id="event_id"
                  className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                  value={eventData.event_id}
                  onChange={(e) => setEventData({ ...eventData, event_id: e.target.value })}
                  required
                />
              </div>
            </div>
            
            {/* Ledger Selection */}
            <div>
              <label htmlFor="ledger_id" className="block text-sm font-medium text-gray-700">
                Ledger
              </label>
              <div className="mt-1">
                <select
                  id="ledger_id"
                  name="ledger_id"
                  className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                  value={eventData.ledger_id}
                  onChange={(e) => setEventData({ ...eventData, ledger_id: e.target.value })}
                  required
                >
                  <option value="">Select a ledger</option>
                  {ledgers && ledgers.map((ledger) => (
                    <option key={ledger.ledger_id} value={ledger.ledger_id}>
                      {ledger.name} (ID: {ledger.ledger_id})
                    </option>
                  ))}
                </select>
              </div>
            </div>
            
            {/* Amount */}
            <div>
              <label htmlFor="amount" className="block text-sm font-medium text-gray-700">
                Amount
              </label>
              <div className="mt-1">
                <input
                  type="number"
                  name="amount"
                  id="amount"
                  className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                  value={eventData.amount}
                  onChange={(e) => setEventData({ ...eventData, amount: e.target.value })}
                  required
                />
              </div>
            </div>
            
            {/* Account Selections */}
            {accountKeys.length > 0 && (
              <div className="space-y-4">
                <h4 className="text-sm font-medium text-gray-700">Account Selections</h4>
                
                {accountKeys.map((key) => (
                  <div key={key}>
                    <label htmlFor={`account-${key}`} className="block text-sm font-medium text-gray-700">
                      {key.charAt(0).toUpperCase() + key.slice(1)} Account
                    </label>
                    <div className="mt-1">
                      <select
                        id={`account-${key}`}
                        name={`account-${key}`}
                        className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                        value={eventData.accounts[key] || ''}
                        onChange={(e) => handleAccountChange(key, e.target.value)}
                        required
                      >
                        <option value="">Select an account</option>
                        {accounts && accounts.map((account) => (
                          <option key={account.account_extra_id} value={account.account_extra_id}>
                            {account.name} (ID: {account.account_extra_id})
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>
                ))}
              </div>
            )}
            
            {/* Metadata Fields */}
            <div>
              <div className="flex justify-between items-center">
                <h4 className="text-sm font-medium text-gray-700">Metadata (Optional)</h4>
                <button
                  type="button"
                  onClick={addMetadataField}
                  className="inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-blue-700 bg-blue-100 hover:bg-blue-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  Add Field
                </button>
              </div>
              
              <div className="mt-2 space-y-3">
                {metadataFields.map((field, index) => (
                  <div key={index} className="flex items-center space-x-2">
                    <input
                      type="text"
                      placeholder="Key"
                      className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                      value={field.key}
                      onChange={(e) => handleMetadataKeyChange(index, e.target.value)}
                    />
                    <input
                      type="text"
                      placeholder="Value"
                      className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
                      value={field.value}
                      onChange={(e) => handleMetadataValueChange(index, e.target.value)}
                    />
                    <button
                      type="button"
                      onClick={() => removeMetadataField(index)}
                      className="inline-flex items-center p-1.5 border border-transparent rounded-full text-red-600 hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                ))}
              </div>
            </div>
            
            {/* Error Message */}
            {error && (
              <div className="rounded-md bg-red-50 p-4">
                <div className="flex">
                  <div className="flex-shrink-0">
                    <svg className="h-5 w-5 text-red-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                    </svg>
                  </div>
                  <div className="ml-3">
                    <h3 className="text-sm font-medium text-red-800">
                      {error}
                    </h3>
                  </div>
                </div>
              </div>
            )}
            
            {/* Submit Buttons */}
            <div className="flex justify-end space-x-3">
              <button
                type="button"
                onClick={onBack}
                className="px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                Back
              </button>
              <button
                type="submit"
                disabled={isLoading || !isFormValid()}
                className={`px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 ${isLoading || !isFormValid() ? 'opacity-50 cursor-not-allowed' : 'hover:bg-blue-700'} focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500`}
              >
                {isLoading ? 'Processing...' : 'Submit Event'}
              </button>
            </div>
          </form>
        )}
      </div>
    </div>
  );
};

export default EventForm;
File: ./src/components/templates/TemplatesList.js
--------------------
import React from 'react';
import { GenericListView, TemplateConfig } from '../common';

/**
 * Templates list component using GenericListView
 */
const TemplatesList = ({ templates, onSelectTemplate, onViewJson, onRefresh, loading }) => {
  return (
    <GenericListView
      data={templates}
      columns={TemplateConfig.listColumns}
      title="Templates"
      idField={TemplateConfig.idField}
      loading={loading}
      onItemClick={onSelectTemplate}
      onViewJson={onViewJson}
      onRefresh={onRefresh}
      searchPlaceholder="Search templates..."
      emptyMessage="No templates found"
    />
  );
};

export default TemplatesList;
File: ./src/components/rules/RuleDetail.js
--------------------
import React from 'react';
import { GenericDetailView, ActionButton, RuleConfig } from '../common';

/**
 * Component to display detailed rule information using GenericDetailView
 */
const RuleDetail = ({ rule, onBack, onViewJson }) => {
  // Define custom sections for the rule detail
  const sections = [
    {
      label: 'Rule ID',
      content: rule?.rule_id
    },
    {
      label: 'Description',
      content: rule?.description
    },
    {
      label: 'Action',
      content: rule?.action && (
        <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
          {rule.action}
        </span>
      )
    },
    {
      label: 'Status',
      content: rule?.status && (
        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
          rule.status === 'ACTIVE' 
            ? 'bg-green-100 text-green-800' 
            : 'bg-gray-100 text-gray-800'
        }`}>
          {rule.status}
        </span>
      )
    },
    {
      label: 'Expression',
      content: rule?.expression && (
        <div className="bg-gray-50 p-4 rounded font-mono overflow-x-auto">
          {rule.expression}
        </div>
      )
    }
  ];

  // Define custom actions
  const customActions = (
    <>
      <ActionButton
        variant="outline"
        onClick={() => onViewJson(rule, `Rule ${rule?.rule_id}`)}
      >
        View JSON
      </ActionButton>
      <ActionButton
        variant="secondary"
        onClick={onBack}
      >
        Back
      </ActionButton>
    </>
  );

  return (
    <GenericDetailView
      data={rule}
      title="Rule Detail"
      subtitle={rule?.name || `Rule ${rule?.rule_id}`}
      sections={sections}
      onBack={onBack}
      onViewJson={onViewJson}
      customActions={customActions}
    />
  );
};

export default RuleDetail;
File: ./src/components/rules/RulesList.js
--------------------
import React from 'react';
import { GenericListView, RuleConfig } from '../common';

/**
 * Component to display a list of rules using GenericListView
 */
const RulesList = ({ rules, onSelectRule, onViewJson, onRefresh, loading }) => {
  // Define additional columns to include with the base configuration
  const columns = [
    ...RuleConfig.listColumns,
    {
      key: 'expression',
      header: 'Expression',
      cellClassName: 'text-gray-500 font-mono',
      render: (rule) => rule.expression && rule.expression.length > 80
        ? `${rule.expression.substring(0, 80)}...`
        : rule.expression
    }
  ];

  return (
    <GenericListView
      data={rules}
      columns={columns}
      title="Rules"
      idField={RuleConfig.idField}
      loading={loading}
      onItemClick={onSelectRule}
      onViewJson={onViewJson}
      onRefresh={onRefresh}
      searchPlaceholder="Search rules..."
      emptyMessage="No rules found"
    />
  );
};

export default RulesList;
File: ./src/components/rules/RulesView.js
--------------------
import React, { useState, useEffect } from 'react';
import { LoadingSpinner, ErrorAlert } from '../common';
import RulesList from './RulesList';
import RuleDetail from './RuleDetail';
import apiService from '../../services/apiService';

/**
 * Main component for the Rules tab
 */
const RulesView = ({ onViewJson }) => {
  const [rules, setRules] = useState([]);
  const [selectedRule, setSelectedRule] = useState(null);
  const [view, setView] = useState('list'); // 'list' or 'detail'
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Fetch rules on component mount
  useEffect(() => {
    fetchRules();
  }, []);

  // Fetch rules from the API
  const fetchRules = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const data = await apiService.transaction.getRules();
      setRules(data);
      setIsLoading(false);
    } catch (err) {
      console.error('Error fetching rules:', err);
      setError(err.message || 'An error occurred while fetching rules');
      setIsLoading(false);
    }
  };

  // Handle rule selection
  const handleSelectRule = (rule) => {
    setSelectedRule(rule);
    setView('detail');
  };

  // Handle back button
  const handleBack = () => {
    setSelectedRule(null);
    setView('list');
  };

  // Error state
  if (error) {
    return (
      <div className="mb-6">
        <ErrorAlert 
          error={error} 
          onRetry={fetchRules} 
        />
      </div>
    );
  }

  return (
    <div>
      {view === 'list' && (
        <RulesList 
          rules={rules}
          onSelectRule={handleSelectRule}
          onViewJson={onViewJson}
          onRefresh={fetchRules}
          loading={isLoading}
        />
      )}
      
      {view === 'detail' && selectedRule && (
        <RuleDetail 
          rule={selectedRule}
          onBack={handleBack}
          onViewJson={onViewJson}
        />
      )}
    </div>
  );
};

export default RulesView;
File: ./src/components/reference/AccountCodesList.js
--------------------
import React, { useState, useEffect } from 'react';
import { GenericListView } from '../common';
import apiService from '../../services/apiService';

/**
 * Account Codes List component using GenericListView
 */
const AccountCodesList = ({ onViewJson, onRefresh }) => {
  const [accountCodes, setAccountCodes] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Define columns for the DataTable
  const columns = [
    {
      key: 'account_code',
      header: 'Code',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'name',
      header: 'Name',
      cellClassName: 'text-gray-500',
      render: (code) => code.name || 'N/A'
    },
    {
      key: 'type',
      header: 'Type',
      cellClassName: 'text-gray-500',
      render: (code) => code.type || 'N/A'
    },
    {
      key: 'description',
      header: 'Description',
      cellClassName: 'text-gray-500',
      render: (code) => code.description || 'N/A'
    }
  ];

  useEffect(() => {
    const loadAccountCodes = async () => {
      setLoading(true);
      try {
        const data = await apiService.reference.getAccountCodes();
        setAccountCodes(data);
        setError(null);
      } catch (err) {
        console.error('Error loading account codes:', err);
        setError('Failed to load account codes. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    loadAccountCodes();
  }, []);

  const handleRefresh = async () => {
    if (onRefresh) {
      onRefresh();
    } else {
      setLoading(true);
      try {
        const data = await apiService.reference.getAccountCodes();
        setAccountCodes(data);
        setError(null);
      } catch (err) {
        console.error('Error refreshing account codes:', err);
        setError('Failed to refresh account codes. Please try again.');
      } finally {
        setLoading(false);
      }
    }
  };

  return (
    <GenericListView
      data={accountCodes}
      columns={columns}
      title="Account Codes"
      idField="account_code"
      loading={loading}
      error={error}
      onViewJson={onViewJson}
      onRefresh={handleRefresh}
      searchPlaceholder="Search account codes..."
      emptyMessage="No account codes found"
    />
  );
};

export default AccountCodesList;
File: ./src/components/reference/CurrenciesList.js
--------------------
import React, { useState, useEffect } from 'react';
import { GenericListView } from '../common';
import apiService from '../../services/apiService';

/**
 * Currencies List component using GenericListView
 */
const CurrenciesList = ({ onViewJson, onRefresh }) => {
  const [currencies, setCurrencies] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Define columns for the DataTable
  const columns = [
    {
      key: 'currency_code',
      header: 'Currency Code',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'type',
      header: 'Type',
      cellClassName: 'text-gray-500',
      render: (currency) => currency.type || 'N/A'
    },
    {
      key: 'scale',
      header: 'Decimal Places',
      cellClassName: 'text-gray-500',
      render: (currency) => typeof currency.scale === 'number' ? currency.scale : 'N/A'
    }
  ];

  useEffect(() => {
    const loadCurrencies = async () => {
      setLoading(true);
      try {
        const data = await apiService.reference.getCurrencies();
        setCurrencies(data);
        setError(null);
      } catch (err) {
        console.error('Error loading currencies:', err);
        setError('Failed to load currencies. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    loadCurrencies();
  }, []);

  const handleRefresh = async () => {
    if (onRefresh) {
      onRefresh();
    } else {
      setLoading(true);
      try {
        const data = await apiService.reference.getCurrencies();
        setCurrencies(data);
        setError(null);
      } catch (err) {
        console.error('Error refreshing currencies:', err);
        setError('Failed to refresh currencies. Please try again.');
      } finally {
        setLoading(false);
      }
    }
  };

  return (
    <GenericListView
      data={currencies}
      columns={columns}
      title="Currencies"
      idField="currency_code"
      loading={loading}
      error={error}
      onViewJson={onViewJson}
      onRefresh={handleRefresh}
      searchPlaceholder="Search currencies..."
      emptyMessage="No currencies found"
    />
  );
};

export default CurrenciesList;
File: ./src/components/reference/CountriesList.js
--------------------
import React, { useState, useEffect } from 'react';
import { GenericListView } from '../common';
import apiService from '../../services/apiService';

/**
 * Countries List component using GenericListView
 */
const CountriesList = ({ onViewJson, onRefresh }) => {
  const [countries, setCountries] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Define columns for the DataTable
  const columns = [
    {
      key: 'country_code',
      header: 'Country Code',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'name',
      header: 'Name',
      cellClassName: 'text-gray-500',
      render: (country) => country.name || 'N/A'
    },
    {
      key: 'region',
      header: 'Region',
      cellClassName: 'text-gray-500',
      render: (country) => country.region || 'N/A'
    }
  ];

  useEffect(() => {
    const loadCountries = async () => {
      setLoading(true);
      try {
        const data = await apiService.reference.getCountries();
        setCountries(data);
        setError(null);
      } catch (err) {
        console.error('Error loading countries:', err);
        setError('Failed to load countries. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    loadCountries();
  }, []);

  const handleRefresh = async () => {
    if (onRefresh) {
      onRefresh();
    } else {
      setLoading(true);
      try {
        const data = await apiService.reference.getCountries();
        setCountries(data);
        setError(null);
      } catch (err) {
        console.error('Error refreshing countries:', err);
        setError('Failed to refresh countries. Please try again.');
      } finally {
        setLoading(false);
      }
    }
  };

  return (
    <GenericListView
      data={countries}
      columns={columns}
      title="Countries"
      idField="country_code"
      loading={loading}
      error={error}
      onViewJson={onViewJson}
      onRefresh={handleRefresh}
      searchPlaceholder="Search countries..."
      emptyMessage="No countries found"
    />
  );
};

export default CountriesList;
File: ./src/components/shared/DetailModal.js
--------------------
import React from 'react';

/**
 * Modal component to display detailed JSON data for any record
 * with improved readability and copy functionality
 */
const DetailModal = ({ isOpen, data, title, onClose }) => {
  if (!isOpen) return null;

  const handleCopyJson = () => {
    navigator.clipboard.writeText(JSON.stringify(data, null, 2))
      .then(() => {
        // Could add a toast notification here
        console.log('JSON copied to clipboard');
      })
      .catch(err => {
        console.error('Failed to copy JSON:', err);
      });
  };

  return (
    <div className="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-screen overflow-y-auto">
        <div className="border-b px-6 py-3 flex justify-between items-center">
          <h3 className="text-lg font-medium text-gray-900">{title}</h3>
          <button 
            onClick={onClose}
            className="text-gray-400 hover:text-gray-500"
          >
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        <div className="p-6">
          {/* Add an explanation of what they're viewing */}
          <p className="mb-4 text-sm text-gray-500">
            Viewing complete data for {title}
          </p>
          
          {/* Add a copy button */}
          <div className="flex justify-end mb-2">
            <button 
              onClick={handleCopyJson}
              className="px-3 py-1 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 text-sm flex items-center"
            >
              <svg className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
                  d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
              </svg>
              Copy JSON
            </button>
          </div>
          
          {/* Improve the JSON display */}
          <pre className="bg-gray-50 p-4 rounded-md overflow-x-auto text-sm border border-gray-200">
            {JSON.stringify(data, null, 2)}
          </pre>
        </div>
      </div>
    </div>
  );
};

export default DetailModal;
File: ./src/components/shared/PageHeader.js
--------------------
import React from 'react';

/**
 * Reusable PageHeader component that optionally includes back and refresh buttons
 */
const PageHeader = ({ title, backButton, refreshButton, onBack, onRefresh }) => {
  return (
    <div className="flex justify-between items-center mb-6">
      <div className="flex items-center">
        {backButton && (
          <button
            onClick={onBack}
            className="mr-4 px-2 py-1 rounded hover:bg-gray-100 transition-colors"
          >
            <span className="text-blue-600">← Back</span>
          </button>
        )}
        <h2 className="text-xl font-semibold text-gray-900">{title}</h2>
      </div>
      {refreshButton && (
        <button
          onClick={onRefresh}
          className="px-3 py-1 rounded border border-gray-200 text-sm text-gray-600 hover:bg-gray-50 flex items-center"
        >
          <svg className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
              d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
          Refresh Data
        </button>
      )}
    </div>
  );
};

export default PageHeader;
File: ./src/components/shared/sidebar/Sidebar.js
--------------------
import React from 'react';

// Using unicode emojis instead of icon libraries to avoid dependencies
const icons = {
  BarChart2: '📊',
  Book: '📘',
  Briefcase: '💼',
  Users: '👥',
  DollarSign: '💱',
  Globe: '🌎',
  Tag: '🏷️',
  FileText: '📄',
  CheckSquare: '✅',
  Shield: '🛡️',
  ChevronLeft: '◀️',
  ChevronRight: '▶️',
  PlusCircle: '➕' // Added for Event Entry
};

/**
 * Sidebar navigation component
 */
const Sidebar = ({ activeTab, onTabChange, collapsed, setCollapsed }) => {
  // Define navigation items with icons and categories
  const mainTabs = [
    { id: 'dashboard', name: 'Balance Sheet', icon: 'BarChart2' },
    { id: 'ledgers', name: 'Ledgers', icon: 'Book' },
    { id: 'accounts', name: 'Accounts', icon: 'Briefcase' },
    { id: 'entities', name: 'Entities', icon: 'Users' },
  ];

  const referenceTabs = [
    { id: 'currencies', name: 'Currencies', icon: 'DollarSign' },
    { id: 'countries', name: 'Countries', icon: 'Globe' },
    { id: 'account-codes', name: 'Account Codes', icon: 'Tag' },
  ];

  const transactionTabs = [
    { id: 'templates', name: 'Templates', icon: 'FileText' },
    { id: 'event-entry', name: 'Event Entry', icon: 'PlusCircle' }, // New menu item
    { id: 'processed-events', name: 'Processed Events', icon: 'CheckSquare' },
    { id: 'rules', name: 'Rules', icon: 'Shield' },
  ];

  // Render navigation item
  const renderNavItem = (tab) => {
    const icon = icons[tab.icon];
    
    return (
      <button
        key={tab.id}
        onClick={() => onTabChange(tab.id)}
        className={`flex items-center w-full py-2 px-3 my-1 rounded ${collapsed ? 'justify-center' : 'px-4'} ${
          activeTab === tab.id
            ? 'bg-blue-50 text-blue-600'
            : 'text-gray-600 hover:bg-gray-50'
        }`}
      >
        <span className={`${collapsed ? '' : 'mr-3'} text-lg`}>{icon}</span>
        {!collapsed && <span className="text-sm">{tab.name}</span>}
      </button>
    );
  };

  // Render section with header
  const renderSection = (title, tabs) => (
    <div className="mb-4 px-2">
      {!collapsed && (
        <div className="px-2 mb-2 text-xs font-semibold text-gray-500 uppercase tracking-wider">
          {title}
        </div>
      )}
      {tabs.map(renderNavItem)}
    </div>
  );

  return (
    <div className={`bg-white border-r border-gray-200 transition-all duration-300 flex flex-col h-full ${collapsed ? 'w-14' : 'w-56'}`}>
      <div className="flex items-center justify-between h-16 px-4 border-b border-gray-200 bg-gray-50">
        {!collapsed && (
          <div className="text-xl font-bold text-gray-900 flex items-center">
            <span className="mr-2">🚀</span>
            Ledger Rocket
          </div>
        )}
        {collapsed && (
          <div className="mx-auto text-xl">
            🚀
          </div>
        )}
        <button
          onClick={() => setCollapsed(!collapsed)}
          className="p-1 rounded-md text-gray-500 hover:bg-gray-200 ml-auto"
        >
          <span className="text-lg">{collapsed ? icons.ChevronRight : icons.ChevronLeft}</span>
        </button>
      </div>
      
      <div className="overflow-y-auto flex-grow py-4">
        {renderSection('Main', mainTabs)}
        {renderSection('Reference', referenceTabs)}
        {renderSection('Transactions', transactionTabs)}
      </div>
    </div>
  );
};

export default Sidebar;
File: ./src/components/shared/sidebar/index.js
--------------------
import Sidebar from './Sidebar';

export default Sidebar;
File: ./src/components/analytics/AnalyticsView.js
--------------------
import React from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';
import PageHeader from '../shared/PageHeader';

// Colors for charts
const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8', '#82ca9d'];

/**
 * Analytics View component to display financial analytics
 * with refresh capability
 */
const AnalyticsView = ({ accounts, entities, onRefresh }) => {
  // Calculate account type breakdown data
  const calculateAccountTypeData = () => {
    if (!accounts || accounts.length === 0) {
      return [];
    }

    const typeMap = {
      'ASSET': 'Assets',
      'LIABILITY': 'Liabilities',
      'EQUITY': 'Equity',
      'REVENUE': 'Revenue',
      'EXPENSE': 'Expenses',
      'CONTINGENT': 'Contingent',
      'MEMO': 'Memo'
    };
    
    const typeBalances = {};
    
    accounts.forEach(account => {
      let type = 'Unknown';
      
      // Extract account type from different possible locations in data structure
      if (account.account_code) {
        if (typeof account.account_code === 'object' && account.account_code.type) {
          type = typeMap[account.account_code.type] || account.account_code.type;
        } else {
          type = account.account_code;
        }
      } else if (account.account_type) {
        type = typeMap[account.account_type] || account.account_type;
      } else if (account.type) {
        type = typeMap[account.type] || account.type;
      }
      
      typeBalances[type] = (typeBalances[type] || 0) + (account.balance || 0);
    });
    
    return Object.keys(typeBalances).map(type => ({
      type,
      value: typeBalances[type] / 100 // Convert cents to dollars for better visualization
    }));
  };

  // Accounts by entity data for pie chart
  const accountsByEntityData = () => {
    if (!accounts || accounts.length === 0 || !entities || entities.length === 0) {
      return [];
    }

    const entityCounts = {};
    
    accounts.forEach(account => {
      const entityId = account.entity_id || 
        (account.enriched_ledger && account.enriched_ledger.entity_id) ||
        (account.entity && account.entity.entity_id);
        
      if (entityId) {
        entityCounts[entityId] = (entityCounts[entityId] || 0) + 1;
      }
    });
    
    return Object.keys(entityCounts).map(entityId => {
      const entity = entities.find(e => e.entity_id === entityId);
      return {
        name: entity ? entity.name : 'Unknown',
        value: entityCounts[entityId]
      };
    });
  };

  const accountTypeData = calculateAccountTypeData();
  const entityAccountsData = accountsByEntityData();

  return (
    <div>
      <PageHeader 
        title="Financial Analytics" 
        refreshButton={true}
        onRefresh={onRefresh}
      />
      
      <div className="bg-white p-6 rounded-lg shadow mb-6">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Account Type Breakdown</h3>
        <ResponsiveContainer width="100%" height={400}>
          <BarChart data={accountTypeData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="type" />
            <YAxis 
              tickFormatter={(value) => 
                value.toLocaleString('en-US', {
                  style: 'currency',
                  currency: 'USD',
                  minimumFractionDigits: 0,
                  maximumFractionDigits: 0
                })
              } 
            />
            <Tooltip 
              formatter={(value) => [
                value.toLocaleString('en-US', {
                  style: 'currency',
                  currency: 'USD',
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2
                }), 
                'Amount'
              ]} 
            />
            <Legend />
            <Bar dataKey="value" fill="#3B82F6" />
          </BarChart>
        </ResponsiveContainer>
      </div>

      <div className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-lg font-medium text-gray-900 mb-4">Accounts Distribution by Entity</h3>
        <ResponsiveContainer width="100%" height={400}>
          <PieChart>
            <Pie
              data={entityAccountsData}
              cx="50%"
              cy="50%"
              labelLine={false}
              outerRadius={160}
              fill="#8884d8"
              dataKey="value"
              label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
            >
              {entityAccountsData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip formatter={(value) => [value, 'Accounts']} />
            <Legend />
          </PieChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
};

export default AnalyticsView;
File: ./src/components/common/LoadingSpinner.js
--------------------
import React from 'react';

/**
 * Reusable loading spinner component with size variants
 * @param {Object} props - Component props
 * @param {string} props.size - Size variant (sm, md, lg)
 * @param {string} props.message - Optional loading message
 * @param {string} props.className - Additional CSS classes
 * @returns {JSX.Element} - Rendered component
 */
const LoadingSpinner = ({ size = 'md', message, className = '' }) => {
  // Define size classes
  const sizeClasses = {
    sm: 'h-4 w-4 border-2',
    md: 'h-8 w-8 border-2',
    lg: 'h-12 w-12 border-4'
  };
  
  // Define text size classes
  const textSizeClasses = {
    sm: 'text-xs',
    md: 'text-sm',
    lg: 'text-base'
  };
  
  return (
    <div className={`flex flex-col items-center justify-center ${className}`}>
      <div className={`animate-spin rounded-full ${sizeClasses[size]} border-b-2 border-blue-500`}></div>
      {message && (
        <p className={`mt-2 text-gray-600 ${textSizeClasses[size]}`}>
          {message}
        </p>
      )}
    </div>
  );
};

export default LoadingSpinner;
File: ./src/components/common/DetailCard.js
--------------------
import React from 'react';

/**
 * Reusable detail card component for showing entity, ledger, account, etc. details
 * Compact grid layout with optional title section and grid of properties
 * @param {Object} props - Component props
 * @param {string|null} props.title - Card title (model name) or null to hide
 * @param {string|null} props.subtitle - Card subtitle (instance name) or null to hide
 * @param {Array} props.sections - Array of section objects with label and content
 * @param {Array} props.childrenSections - Array of child sections (like tables) to display below basic info
 * @param {React.ReactNode} props.actions - Optional action buttons to display
 * @returns {JSX.Element} - Rendered component
 */
const DetailCard = ({ title, subtitle, sections, childrenSections = [], actions }) => {
  // Filter basic fields vs complex table sections
  const basicSections = [];
  const tableSections = [];
  
  // Process main sections
  sections.forEach((section) => {
    // Check if this section contains complex content like tables
    const hasTableContent = 
      section.content && 
      typeof section.content === 'object' &&
      React.isValidElement(section.content) &&
      (
        section.content.type === 'table' ||
        section.content.props?.className?.includes('overflow-x-auto') ||
        section.content.props?.children?.type === 'table' ||
        (section.content.props?.children && 
         React.isValidElement(section.content.props.children) && 
         section.content.props.children.type === 'table')
      );
    
    // Skip 'Name' fields only if we're showing a subtitle
    const isNameField = 
      subtitle && (
        section.label === 'Name' || 
        section.label?.toLowerCase() === 'name' || 
        section.label?.includes('Name')
      );
    
    if (hasTableContent) {
      tableSections.push(section);
    } else if (!isNameField) { 
      // Add to basic sections if not a name field (or if we have no subtitle)
      basicSections.push(section);
    }
  });
  
  // Add all children sections to tableSections
  tableSections.push(...childrenSections);
  
  return (
    <div>
      {/* Header section with title and actions - only show if we have a title/subtitle or actions */}
      {(title || subtitle || actions) && (
        <div className="bg-white rounded-lg shadow overflow-hidden mb-6">
          <div className="px-6 py-4 flex justify-between items-center">
            {(title || subtitle) && (
              <div>
                {title && <h2 className="text-xl font-semibold text-gray-900">{title}</h2>}
                {subtitle && <p className="mt-1 text-base text-gray-600">{subtitle}</p>}
              </div>
            )}
            {actions && (
              <div className={`flex space-x-3 ${!title && !subtitle ? 'ml-auto' : ''}`}>
                {actions}
              </div>
            )}
          </div>
        </div>
      )}
      
      {/* Basic fields in compact grid */}
      {basicSections.length > 0 && (
        <div className="bg-white rounded-lg shadow overflow-hidden mb-6">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-0 divide-gray-100">
            {basicSections.map((section, index) => (
              <div 
                key={`basic-section-${index}`}
                className={`p-4 ${index % 2 === 0 ? 'bg-gray-50' : 'bg-white'}`}
              >
                <p className="text-sm font-medium text-gray-500 mb-1">
                  {section.label}
                </p>
                <div className="text-sm text-gray-900">
                  {section.content}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}
      
      {/* Table sections (full width) */}
      {tableSections.length > 0 && (
        <div className="space-y-6">
          {tableSections.map((section, index) => (
            <div 
              key={`table-section-${index}`}
              className="bg-white shadow rounded-lg overflow-hidden"
            >
              <div className="px-4 py-3 bg-gray-50 border-b border-gray-200">
                <h3 className="text-sm font-medium text-gray-700">
                  {section.label}
                </h3>
              </div>
              <div className="p-0">
                {section.content}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default DetailCard;
File: ./src/components/common/config/modelConfig.js
--------------------
/**
 * Model configuration for the application
 * Centralizes common definitions for different model types
 */
import { formatBalance, formatAccountCode, getCountryDisplay, getAccountType, getBalanceClass, getCurrencyInfo } from '../../../utils/formatters';

/**
 * Entity model configuration
 */
export const EntityConfig = {
  title: 'Entity',
  idField: 'entity_id',
  displayField: 'name',
  
  // Column definitions for list view
  listColumns: [
    {
      key: 'entity_id',
      header: 'ID',
      cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
    },
    {
      key: 'name',
      header: 'Name',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'type',
      header: 'Type',
      render: (entity) => entity.type || entity.entity_type || 'N/A'
    },
    {
      key: 'country',
      header: 'Country',
      render: (entity) => getCountryDisplay(entity)
    },
    {
      key: 'ledger_count',
      header: 'Ledgers',
      render: (entity) => entity.ledger_count || (entity.ledgers && entity.ledgers.length) || 0
    }
  ],
  
  // Basic section fields for detail view
  detailSections: (entity) => [
    {
      label: 'Entity ID',
      content: entity.entity_id
    },
    {
      label: 'Name',
      content: entity.name
    },
    {
      label: 'Type',
      content: entity.type || entity.entity_type || 'N/A'
    },
    {
      label: 'Country',
      content: getCountryDisplay(entity)
    },
    {
      label: 'Description',
      content: entity.description || 'No description'
    }
  ]
};

/**
 * Ledger model configuration
 */
export const LedgerConfig = {
  title: 'Ledger',
  idField: 'ledger_id',
  displayField: 'name',
  
  // Column definitions for list view
  listColumns: [
    {
      key: 'ledger_id',
      header: 'ID',
      cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
    },
    {
      key: 'name',
      header: 'Name',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'entity',
      header: 'Owner',
      render: (ledger) => ledger.r_entity ? ledger.r_entity.name : (ledger.entity ? ledger.entity.name : 'N/A')
    },
    {
      key: 'currency',
      header: 'Currency',
      render: (ledger) => ledger.r_currency ? `${ledger.r_currency.currency_code}` : (ledger.currency_code || 'N/A')
    },
    {
      key: 'country',
      header: 'Country',
      render: (ledger) => getCountryDisplay(ledger)
    }
  ],
  
  // Basic section fields for detail view
  detailSections: (ledger, entity) => [
    {
      label: 'Ledger ID',
      content: ledger.ledger_id
    },
    {
      label: 'Name',
      content: ledger.name
    },
    {
      label: 'Owner',
      content: entity ? entity.name : (ledger.r_entity ? ledger.r_entity.name : 'N/A')
    },
    {
      label: 'Currency',
      content: ledger.r_currency ? `${ledger.r_currency.currency_code} (${ledger.r_currency.type})` : 'N/A'
    },
    {
      label: 'Country',
      content: getCountryDisplay(ledger)
    },
    {
      label: 'Description',
      content: ledger.description || 'No description'
    }
  ]
};

/**
 * Account model configuration
 */
export const AccountConfig = {
  title: 'Account',
  idField: 'account_id',
  altIdField: 'account_extra_id', // Alternative ID field for accounts
  displayField: 'name',
  
  // Column definitions for list view
  listColumns: [
    {
      key: 'account_id',
      header: 'ID',
      cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
      render: (account) => account.account_id || account.account_extra_id || 'N/A'
    },
    {
      key: 'name',
      header: 'Account Name',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'account_code',
      header: 'Account Code',
      render: (account) => formatAccountCode(account.account_code || account.code)
    },
    {
      key: 'account_type',
      header: 'Type',
      render: (account) => getAccountType(account)
    },
    {
      key: 'balance',
      header: 'Balance',
      align: 'right',
      cellClassName: (account) => getBalanceClass(account.balance),
      render: (account) => {
        const currency = getCurrencyInfo(account);
        return formatBalance(account.balance, currency, true);
      }
    }
  ],
  
  // Basic section fields for detail view
  detailSections: (account, entity, ledger) => [
    {
      label: 'Account ID',
      content: account.account_id || account.account_extra_id || 'N/A'
    },
    {
      label: 'Name',
      content: account.name
    },
    {
      label: 'Account Type',
      content: getAccountType(account)
    },
    {
      label: 'Account Code',
      content: formatAccountCode(account.account_code || account.code)
    },
    {
      label: 'Currency',
      content: (ledger && ledger.r_currency && ledger.r_currency.currency_code) || 
               account.currency_code || 
               'N/A'
    },
    {
      label: 'Current Balance',
      content: (
        <span className={getBalanceClass(account.balance)}>
          {formatBalance(account.balance, getCurrencyInfo(account), true)}
        </span>
      )
    }
  ]
};

/**
 * Template model configuration
 */
export const TemplateConfig = {
  title: 'Template',
  idField: 'template_id',
  displayField: 'name',
  
  // Column definitions for list view
  listColumns: [
    {
      key: 'template_id',
      header: 'ID',
      cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
    },
    {
      key: 'name',
      header: 'Template Name',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'product',
      header: 'Type',
      cellClassName: 'text-gray-500',
    },
    {
      key: 'description',
      header: 'Description',
      cellClassName: 'text-gray-500',
      render: (item) => {
        return item.description.length > 100 
          ? `${item.description.substring(0, 100)}...` 
          : item.description;
      }
    },
    {
      key: 'created_date',
      header: 'Created',
      cellClassName: 'text-gray-500',
      render: (item) => {
        return new Date(item.created_date * 1000).toLocaleDateString();
      }
    }
  ],
  
  // Format field names by removing underscores and capitalizing each word
  formatFieldName: (fieldName) => {
    return fieldName
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  },
  
  // Helper to render variable section
  renderVariablesSection: (template) => {
    return {
      label: 'Variables',
      content: (
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Value</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {template.variables.map((variable, index) => (
                <tr key={index}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    {TemplateConfig.formatFieldName(variable.name)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{variable.value}</td>
                </tr>
              ))}
              {template.variables.length === 0 && (
                <tr>
                  <td colSpan={2} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">No variables defined</td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      )
    };
  },
  
  // Helper to render validations section
  renderValidationsSection: (template) => {
    return {
      label: 'Validations',
      content: (
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Expression</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {template.validations.map((validation, index) => (
                <tr key={index}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    {TemplateConfig.formatFieldName(validation.name)}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{validation.expression}</td>
                  <td className="px-6 py-4 whitespace-normal text-sm text-gray-500">{validation.description}</td>
                </tr>
              ))}
              {template.validations.length === 0 && (
                <tr>
                  <td colSpan={3} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">No validations defined</td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      )
    };
  },
  
  // Helper to render legs section
  renderLegsSection: (template) => {
    return {
      label: 'Template Legs',
      content: (
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Leg Number</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Debit Account</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Credit Account</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Code</th>
                <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {template.legs.map((leg, index) => (
                <tr key={index}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{leg.leg_number}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{leg.debit_account}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{leg.credit_account}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{leg.code}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{leg.amount}</td>
                </tr>
              ))}
              {template.legs.length === 0 && (
                <tr>
                  <td colSpan={5} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">No legs defined</td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      )
    };
  },
  
  // Basic section fields for detail view
  detailSections: (template) => {
    if (!template) return [];
    
    return [
      {
        label: 'Template ID',
        content: template.template_id
      },
      {
        label: 'Name',
        content: template.name
      },
      {
        label: 'Description',
        content: template.description
      },
      {
        label: 'Product Type',
        content: template.product
      },
      {
        label: 'Created',
        content: `${new Date(template.created_date * 1000).toLocaleString()} by ${template.created_by}`
      }
    ];
  },
  
  // Get all sections including tables
  getAllSections: (template) => {
    if (!template) return [];
    
    return [
      ...TemplateConfig.detailSections(template),
      TemplateConfig.renderVariablesSection(template),
      TemplateConfig.renderValidationsSection(template),
      TemplateConfig.renderLegsSection(template)
    ];
  }
};

/**
 * ProcessedEvent model configuration
 */
export const ProcessedEventConfig = {
  title: 'Processed Event',
  idField: 'processed_event_id',
  displayField: 'description',
  
  // Column definitions for list view
  listColumns: [
    {
      key: 'processed_event_id',
      header: 'ID',
      cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
    },
    {
      key: 'status',
      header: 'Status',
      cellClassName: (item) => {
        return item.status === 'COMPLETED' 
          ? 'text-green-600 font-medium' 
          : item.status === 'FAILED' 
            ? 'text-red-600 font-medium' 
            : 'text-yellow-600 font-medium';
      }
    },
    {
      key: 'template_id',
      header: 'Template',
      render: (item) => item.template ? item.template.name : item.template_id
    },
    {
      key: 'created_date',
      header: 'Created',
      render: (item) => new Date(item.created_date * 1000).toLocaleString()
    },
    {
      key: 'completed_date',
      header: 'Completed',
      render: (item) => item.completed_date ? new Date(item.completed_date * 1000).toLocaleString() : 'N/A'
    }
  ]
};

/**
 * Rule model configuration
 */
export const RuleConfig = {
  title: 'Rule',
  idField: 'rule_id',
  displayField: 'name',
  
  // Column definitions for list view
  listColumns: [
    {
      key: 'rule_id',
      header: 'ID',
      cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
    },
    {
      key: 'name',
      header: 'Name',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'type',
      header: 'Type',
      cellClassName: 'text-gray-500',
    },
    {
      key: 'status',
      header: 'Status',
      cellClassName: (item) => {
        return item.status === 'ACTIVE' 
          ? 'text-green-600 font-medium' 
          : 'text-gray-500';
      }
    },
    {
      key: 'created_date',
      header: 'Created',
      render: (item) => new Date(item.created_date * 1000).toLocaleString()
    }
  ]
};

// Export all configurations
export default {
  EntityConfig,
  LedgerConfig,
  AccountConfig,
  TemplateConfig,
  ProcessedEventConfig,
  RuleConfig
};
File: ./src/components/common/FilterBadge.js
--------------------
import React from 'react';

/**
 * Badge component for showing active filters with clear option
 * @param {Object} props - Component props
 * @param {string} props.label - Filter description (e.g. "Account Type: Liability")
 * @param {function} props.onClear - Function to clear the filter
 * @param {number} props.count - Number of items matching the filter
 * @param {string} props.entityName - Name of the entity being filtered (e.g. "account")
 * @param {string} props.className - Additional CSS classes
 * @returns {JSX.Element} - Rendered component
 */
const FilterBadge = ({ 
  label, 
  onClear, 
  count = 0, 
  entityName = 'item', 
  className = '' 
}) => {
  return (
    <div className={`bg-blue-50 p-4 rounded-lg flex justify-between items-center ${className}`}>
      <div>
        <p className="text-blue-700 font-medium">{label}</p>
        <p className="text-sm text-blue-600">
          Showing {count} {count === 1 ? entityName : `${entityName}s`}
        </p>
      </div>
      <button
        onClick={onClear}
        className="px-3 py-1 bg-white border border-blue-300 rounded-md text-blue-600 hover:bg-blue-50 text-sm flex items-center"
      >
        <span className="mr-1">Clear Filter</span>
        <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
  );
};

export default FilterBadge;
File: ./src/components/common/SectionHeader.js
--------------------
import React from 'react';

/**
 * Reusable section header component with title, description, and action buttons
 * @param {Object} props - Component props
 * @param {string} props.title - Section title
 * @param {string} props.description - Optional section description
 * @param {React.ReactNode} props.actions - Optional action buttons
 * @param {string} props.className - Additional CSS classes
 * @returns {JSX.Element} - Rendered component
 */
const SectionHeader = ({ title, description, actions, className = '' }) => {
  return (
    <div className={`mb-5 flex flex-col sm:flex-row sm:items-center sm:justify-between ${className}`}>
      <div>
        <h3 className="text-lg leading-6 font-medium text-gray-900">
          {title}
        </h3>
        {description && (
          <p className="mt-1 text-sm text-gray-500">
            {description}
          </p>
        )}
      </div>
      {actions && (
        <div className="mt-3 flex sm:mt-0 sm:ml-4 space-x-3">
          {actions}
        </div>
      )}
    </div>
  );
};

export default SectionHeader;
File: ./src/components/common/DataTable.js
--------------------
import React from 'react';

/**
 * Reusable data table component with universal ID column drilldown
 * @param {Object} props - Component props
 * @param {Array} props.columns - Table column definitions with keys, headers, and render functions
 * @param {Array} props.data - Data to display in the table
 * @param {boolean} props.loading - Loading state
 * @param {function} props.onRowClick - Function to call when a row is clicked
 * @param {string} props.emptyMessage - Message to display when there is no data
 * @param {number} props.colSpan - Number of columns for loading and empty states
 * @param {string} props.idField - Name of the ID field (default: first column key)
 * @returns {JSX.Element} - Rendered component
 */
const DataTable = ({ 
  columns, 
  data = [], 
  loading = false,
  onRowClick,
  emptyMessage = 'No data found',
  colSpan = 5,
  className = '',
  idField = null
}) => {
  // If idField is not explicitly specified, use the key of the first column
  const actualIdField = idField || (columns.length > 0 ? columns[0].key : null);
  
  // Make sure the first column is styled as a drilldown link if we have an onRowClick handler
  const processedColumns = columns.map((column, index) => {
    if (index === 0 && onRowClick) {
      return {
        ...column,
        cellClassName: column.cellClassName || 'text-blue-600 hover:underline cursor-pointer font-medium'
      };
    }
    return column;
  });

  return (
    <div className={`bg-white shadow overflow-hidden rounded-lg ${className}`}>
      <div className="overflow-x-auto">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              {processedColumns.map(column => (
                <th 
                  key={column.key} 
                  className={`px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider ${column.headerClassName || ''}`}
                >
                  {column.header}
                </th>
              ))}
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {loading ? (
              <tr>
                <td colSpan={colSpan} className="px-6 py-4 text-center">
                  <div className="flex justify-center">
                    <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
                  </div>
                </td>
              </tr>
            ) : data.length > 0 ? (
              data.map((item, index) => (
                <tr 
                  key={item.id || index} 
                  className="hover:bg-gray-50"
                  style={onRowClick ? { cursor: 'pointer' } : {}}
                >
                  {processedColumns.map((column, colIndex) => (
                    <td 
                      key={`${item.id || index}-${column.key}`} 
                      className={`px-6 py-4 whitespace-nowrap text-sm ${column.cellClassName || 'text-gray-500'}`}
                      onClick={(e) => {
                        // If this is the first column, always handle the click
                        if (colIndex === 0 && onRowClick) {
                          e.stopPropagation();
                          onRowClick(item);
                        } else if (column.onClick) {
                          // If the column has its own click handler, use that
                          e.stopPropagation();
                          column.onClick(item);
                        } else if (onRowClick && !column.preventRowClick) {
                          // For other columns, trigger the row click handler unless prevented
                          onRowClick(item);
                        }
                      }}
                    >
                      {column.render ? column.render(item) : item[column.key]}
                    </td>
                  ))}
                </tr>
              ))
            ) : (
              <tr>
                <td colSpan={colSpan} className="px-6 py-4 text-center text-sm text-gray-500">
                  {emptyMessage}
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default DataTable;
File: ./src/components/common/index.js
--------------------
export { default as ActionButton } from './ActionButton';
export { default as DataTable } from './DataTable';
export { default as DataTableSection } from './DataTableSection';
export { default as DetailCard } from './DetailCard';
export { default as ErrorAlert } from './ErrorAlert';
export { default as FilterBadge } from './FilterBadge';
export { default as GenericDetailView } from './GenericDetailView';
export { default as GenericListView } from './GenericListView';
export { default as LoadingSpinner } from './LoadingSpinner';
export { default as SectionHeader } from './SectionHeader';
export { default as StandardList } from './StandardList';

// Export model configurations
export * from './config/modelConfig';
File: ./src/components/common/GenericDetailView.js
--------------------
import React from 'react';
import { DetailCard, ActionButton, ErrorAlert, LoadingSpinner } from './index';

/**
 * Generic Detail View component for displaying any model type
 * This centralizes the pattern of showing detailed information about entities, accounts, ledgers, etc.
 * 
 * @param {Object} props - Component props
 * @param {Object} props.data - The data object to display
 * @param {string} props.title - The title of the detail view (e.g., "Entity Detail")
 * @param {string} props.subtitle - The subtitle or name of the specific item
 * @param {Array} props.sections - Array of section objects to display in the detail card (basic info)
 * @param {Array} props.childrenSections - Optional array of child relationship sections with tables
 * @param {boolean} props.loading - Whether data is loading
 * @param {Object|string} props.error - Error state if present
 * @param {function} props.onBack - Handler for going back
 * @param {function} props.onRefresh - Handler for refreshing data
 * @param {function} props.onViewJson - Handler for viewing JSON data
 * @param {string} props.loadingMessage - Custom loading message
 * @param {React.ReactNode} props.customActions - Custom actions to display
 * @returns {JSX.Element}
 */
const GenericDetailView = ({
  data,
  title,
  subtitle,
  sections = [],
  childrenSections = [],
  loading = false,
  error = null,
  onBack,
  onRefresh,
  onViewJson,
  loadingMessage,
  customActions,
}) => {
  // Display loading state
  if (loading && !data) {
    return (
      <div className="h-64 flex items-center justify-center">
        <LoadingSpinner size="lg" message={loadingMessage || `Loading ${title.toLowerCase()}...`} />
      </div>
    );
  }

  // Display error state
  if (error) {
    return (
      <div className="mb-6">
        <ErrorAlert error={error} onRetry={onRefresh} />
        <div className="mt-4">
          <ActionButton variant="primary" onClick={onBack}>
            Back
          </ActionButton>
        </div>
      </div>
    );
  }

  // Handle missing data
  if (!data) {
    return (
      <div className="text-center py-12">
        <p className="text-gray-500">No {title.toLowerCase()} selected.</p>
        <div className="mt-4">
          <ActionButton variant="primary" onClick={onBack}>
            Back
          </ActionButton>
        </div>
      </div>
    );
  }

  // Standard actions for the detail card
  const defaultActions = (
    <>
      <ActionButton
        variant="outline"
        onClick={() => onViewJson && onViewJson(data, `${title}: ${subtitle || ''}`)}
      >
        View JSON
      </ActionButton>
      <ActionButton
        variant="outline"
        onClick={onRefresh}
        icon={
          <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
              d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        }
      >
        Refresh
      </ActionButton>
      <ActionButton variant="secondary" onClick={onBack}>
        Back
      </ActionButton>
    </>
  );

  return (
    <div>
      <DetailCard
        title={title}
        subtitle={subtitle}
        sections={sections}
        childrenSections={childrenSections}
        actions={customActions || defaultActions}
      />
    </div>
  );
};

export default GenericDetailView;
File: ./src/components/common/ActionButton.js
--------------------
import React from 'react';

/**
 * Reusable action button component with consistent styling
 * @param {Object} props - Component props
 * @param {React.ReactNode} props.children - Button content
 * @param {React.ReactNode} props.icon - Optional icon
 * @param {string} props.variant - Button variant (primary, secondary, outline, danger)
 * @param {function} props.onClick - Click handler
 * @param {string} props.className - Additional CSS classes
 * @param {boolean} props.disabled - Whether the button is disabled
 * @returns {JSX.Element} - Rendered component
 */
const ActionButton = ({ 
  children, 
  icon, 
  variant = 'primary', 
  onClick, 
  className = '',
  disabled = false
}) => {
  // Define button styles based on variant
  const baseStyle = "inline-flex items-center justify-center px-4 py-2 border text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2";
  
  const variantStyles = {
    primary: "border-transparent text-white bg-blue-600 hover:bg-blue-700 focus:ring-blue-500",
    secondary: "border-transparent text-white bg-gray-600 hover:bg-gray-700 focus:ring-gray-500",
    outline: "border-gray-300 text-gray-700 bg-white hover:bg-gray-50 focus:ring-blue-500",
    danger: "border-transparent text-white bg-red-600 hover:bg-red-700 focus:ring-red-500"
  };
  
  const disabledStyle = disabled ? "opacity-50 cursor-not-allowed" : "";
  
  return (
    <button
      type="button"
      className={`${baseStyle} ${variantStyles[variant]} ${className} ${disabledStyle}`}
      onClick={onClick}
      disabled={disabled}
    >
      {icon && (
        <span className="mr-2 -ml-1 h-5 w-5">
          {icon}
        </span>
      )}
      {children}
    </button>
  );
};

export default ActionButton;
File: ./src/components/common/StandardList.js
--------------------
import React, { useState } from 'react';
import { 
  DataTable, 
  SectionHeader, 
  ActionButton,
  ErrorAlert,
  LoadingSpinner
} from './index';

/**
 * Standard List component that can be used for any type of data
 * Provides consistent behavior for ID column clicking and other common list features
 * 
 * @param {Object} props - Component props
 * @param {Array} props.data - Data items to display
 * @param {Array} props.columns - Column definitions
 * @param {string} props.title - List title
 * @param {string} props.idField - Field name of the ID column
 * @param {boolean} props.loading - Loading state
 * @param {Object} props.error - Error state
 * @param {function} props.onItemClick - Function to call when an item is clicked
 * @param {function} props.onViewJson - Function to call to view item JSON
 * @param {function} props.onRefresh - Function to call to refresh the data
 * @param {function} props.onSearch - Function to call when search changes (optional)
 * @param {string} props.searchPlaceholder - Placeholder for search box
 * @param {string} props.emptyMessage - Message to display when no data is found
 * @param {string} props.searchQuery - External search query (optional)
 * @param {function} props.setSearchQuery - Function to update external search query (optional)
 * @returns {JSX.Element} - Rendered component
 */
const StandardList = ({ 
  data = [],
  columns,
  title,
  idField,
  loading = false,
  error = null,
  onItemClick,
  onViewJson,
  onRefresh,
  onSearch,
  searchPlaceholder = "Search...",
  emptyMessage = "No items found",
  searchQuery: externalSearchQuery,
  setSearchQuery: setExternalSearchQuery
}) => {
  // Use internal state if external search query is not provided
  const [internalSearchQuery, setInternalSearchQuery] = useState('');
  
  // Determine whether to use external or internal search state
  const searchQuery = externalSearchQuery !== undefined ? externalSearchQuery : internalSearchQuery;
  const setSearchQuery = setExternalSearchQuery || setInternalSearchQuery;
  
  // Filter data based on search query if onSearch is not provided
  const filteredData = onSearch ? data : (
    searchQuery
      ? data.filter(item => {
          // Generic search across all string and number properties
          return Object.entries(item).some(([key, value]) => {
            if (typeof value === 'string') {
              return value.toLowerCase().includes(searchQuery.toLowerCase());
            } else if (typeof value === 'number') {
              return value.toString().includes(searchQuery);
            }
            return false;
          });
        })
      : data
  );
  
  // Make sure the first column is the ID column and has proper click behavior
  const processedColumns = columns.map((column, index) => {
    if (index === 0 && column.key === idField) {
      return {
        ...column,
        cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
      };
    }
    return column;
  });
  
  /**
   * Handle search input change
   * @param {Event} e - Input change event
   */
  const handleSearchChange = (e) => {
    const newValue = e.target.value;
    setSearchQuery(newValue);
    
    if (onSearch) {
      onSearch(newValue);
    }
  };
  
  /**
   * Handle refreshing data
   */
  const handleRefresh = () => {
    if (onRefresh) {
      onRefresh();
    }
  };
  
  /**
   * Handle clicking on an item
   * @param {Object} item - Item that was clicked
   */
  const handleItemClick = (item) => {
    if (onItemClick) {
      // Use the ID field to determine which ID to pass
      const itemId = item[idField];
      onItemClick(item, itemId);
    }
  };
  
  // Define JSON view function for the Actions column
  const handleViewJson = (item) => {
    if (onViewJson) {
      onViewJson(item, `${title}: ${item[idField] || 'Detail'}`);
    }
  };
  
  // Render action buttons for the section header
  const renderActions = () => (
    <>
      <div className="relative mr-2">
        <input
          type="text"
          placeholder={searchPlaceholder}
          className="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-gray-300 rounded-md"
          value={searchQuery}
          onChange={handleSearchChange}
        />
      </div>
      <ActionButton
        variant="outline"
        onClick={handleRefresh}
        icon={
          <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} 
              d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        }
      >
        Refresh Data
      </ActionButton>
    </>
  );
  
  // Show loading spinner if data is loading and there's no data
  if (loading && data.length === 0) {
    return (
      <div className="h-64 flex items-center justify-center">
        <LoadingSpinner size="lg" message={`Loading ${title.toLowerCase()}...`} />
      </div>
    );
  }
  
  return (
    <div>
      <SectionHeader
        title={title}
        description={`${filteredData.length} ${title.toLowerCase()} found`}
        actions={renderActions()}
      />
      
      {error && (
        <ErrorAlert 
          error={error} 
          onRetry={handleRefresh} 
          className="mb-4"
        />
      )}
      
      <DataTable
        columns={processedColumns}
        data={filteredData}
        loading={loading}
        onRowClick={handleItemClick}
        emptyMessage={emptyMessage}
        colSpan={columns.length}
        idField={idField}
      />
    </div>
  );
};

export default StandardList;
File: ./src/components/common/GenericListView.js
--------------------
import React, { useState } from 'react';
import { StandardList, FilterBadge, ErrorAlert, LoadingSpinner } from './index';

/**
 * Generic List View component for displaying any model type in a list
 * This centralizes the pattern of showing lists of entities, accounts, ledgers, etc.
 * 
 * @param {Object} props - Component props
 * @param {Array} props.data - The data array to display
 * @param {Array} props.columns - Column definitions for the list
 * @param {string} props.title - Title for the list (e.g., "Accounts")
 * @param {string} props.idField - The field to use as the ID (e.g., "account_id")
 * @param {boolean} props.loading - Whether data is loading
 * @param {Object|string} props.error - Error state if present
 * @param {function} props.onItemClick - Handler for clicking an item
 * @param {function} props.onViewJson - Handler for viewing JSON data
 * @param {function} props.onRefresh - Handler for refreshing data
 * @param {Object} props.filter - Active filter (e.g., { field: 'type', value: 'ASSET' })
 * @param {function} props.onClearFilter - Handler for clearing the active filter
 * @param {function} props.onSearch - Custom search handler
 * @param {string} props.searchPlaceholder - Placeholder for the search input
 * @param {string} props.emptyMessage - Message to display when no data is found
 * @param {React.ReactNode} props.customHeader - Custom header content
 * @param {React.ReactNode} props.customActions - Custom actions for the list
 * @returns {JSX.Element}
 */
const GenericListView = ({
  data = [],
  columns,
  title,
  idField,
  loading = false,
  error = null,
  onItemClick,
  onViewJson,
  onRefresh,
  filter = null,
  onClearFilter,
  onSearch,
  searchPlaceholder,
  emptyMessage,
  customHeader,
  customActions,
}) => {
  // Display loading state
  if (loading && data.length === 0) {
    return (
      <div className="h-64 flex items-center justify-center">
        <LoadingSpinner size="lg" message={`Loading ${title.toLowerCase()}...`} />
      </div>
    );
  }

  // Display error state
  if (error) {
    return (
      <div className="mb-6">
        <ErrorAlert error={error} onRetry={onRefresh} />
      </div>
    );
  }

  // Generate a filter badge if a filter is active
  const filterBadge = filter ? (
    <div className="mb-4">
      <FilterBadge
        label={`${filter.label || filter.field}: ${filter.value}`}
        onClear={onClearFilter}
        count={data.length}
        entityName={title.toLowerCase()}
      />
    </div>
  ) : null;

  return (
    <div>
      {customHeader || filterBadge}
      <StandardList
        data={data}
        columns={columns}
        title={title}
        idField={idField}
        onItemClick={onItemClick}
        onViewJson={onViewJson}
        onRefresh={onRefresh}
        onSearch={onSearch}
        searchPlaceholder={searchPlaceholder || `Search ${title.toLowerCase()}...`}
        emptyMessage={emptyMessage || `No ${title.toLowerCase()} found`}
        customActions={customActions}
      />
    </div>
  );
};

export default GenericListView;
File: ./src/components/common/ErrorAlert.js
--------------------
import React from 'react';

/**
 * Reusable error alert component for displaying error messages
 * @param {Object} props - Component props
 * @param {string|Error} props.error - Error message or object
 * @param {function} props.onRetry - Optional retry function
 * @param {string} props.className - Additional CSS classes
 * @returns {JSX.Element} - Rendered component
 */
const ErrorAlert = ({ error, onRetry, className = '' }) => {
  // Parse error message from string or Error object
  const errorMessage = error instanceof Error ? error.message : error;
  
  return (
    <div className={`bg-red-50 border-l-4 border-red-400 p-4 ${className}`}>
      <div className="flex">
        <div className="flex-shrink-0">
          <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
          </svg>
        </div>
        <div className="ml-3">
          <p className="text-sm text-red-700">
            {errorMessage}
          </p>
          {onRetry && (
            <div className="mt-2">
              <button
                type="button"
                className="px-2 py-1 text-xs font-medium rounded-md text-red-700 bg-red-100 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
                onClick={onRetry}
              >
                Retry
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default ErrorAlert;
File: ./src/components/common/DataTableSection.js
--------------------
import React from 'react';

/**
 * Reusable component for creating data tables inside detail views
 * 
 * @param {Object} props - Component props
 * @param {Array} props.data - Array of data objects to display
 * @param {Array} props.columns - Column definitions
 * @param {string} props.title - Table section title
 * @param {function} props.onRowClick - Handler for clicking a row
 * @param {string} props.emptyMessage - Message to display when no data is available
 * @param {function} props.sortFunction - Optional function to sort data
 * @returns {JSX.Element}
 */
const DataTableSection = ({
  data = [],
  columns = [],
  title,
  onRowClick,
  emptyMessage = 'No data available',
  sortFunction
}) => {
  // Sort data if a sort function is provided
  const displayData = sortFunction ? [...data].sort(sortFunction) : data;

  return (
    <div className="overflow-x-auto">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            {columns.map((column, index) => (
              <th 
                key={`header-${index}`}
                className={`px-6 py-3 text-xs font-medium text-gray-500 uppercase tracking-wider ${
                  column.align === 'right' ? 'text-right' : 
                  column.align === 'center' ? 'text-center' : 'text-left'
                }`}
              >
                {column.header}
              </th>
            ))}
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {displayData && displayData.length > 0 ? (
            displayData.map((item, rowIndex) => (
              <tr 
                key={`row-${rowIndex}`} 
                className="hover:bg-gray-50"
                onClick={() => onRowClick && onRowClick(item)}
                style={onRowClick ? { cursor: 'pointer' } : {}}
              >
                {columns.map((column, colIndex) => {
                  // Determine cell content
                  let content = item[column.key];
                  if (column.render) {
                    content = column.render(item);
                  }

                  // Determine cell className
                  let className = `px-6 py-4 whitespace-nowrap text-sm ${
                    column.align === 'right' ? 'text-right' : 
                    column.align === 'center' ? 'text-center' : 'text-left'
                  }`;
                  
                  if (typeof column.cellClassName === 'function') {
                    className += ` ${column.cellClassName(item)}`;
                  } else if (column.cellClassName) {
                    className += ` ${column.cellClassName}`;
                  }

                  // Handle cell click
                  const handleCellClick = (e) => {
                    if (column.onClick) {
                      const stopPropagation = column.onClick(item, e);
                      if (stopPropagation) {
                        e.stopPropagation();
                      }
                    }
                  };

                  return (
                    <td 
                      key={`cell-${rowIndex}-${colIndex}`} 
                      className={className}
                      onClick={column.onClick ? handleCellClick : undefined}
                      style={column.onClick ? { cursor: 'pointer' } : {}}
                    >
                      {content}
                    </td>
                  );
                })}
              </tr>
            ))
          ) : (
            <tr>
              <td colSpan={columns.length} className="px-6 py-4 text-center text-sm text-gray-500">
                {emptyMessage}
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
};

export default DataTableSection;
File: ./src/components/dashboard/layout/DashboardHeader.js
--------------------
import React from 'react';
import { useDashboard } from '../../../context/DashboardContext';

/**
 * Dashboard header component with auto-refresh controls
 */
const DashboardHeader = () => {
  const { 
    autoRefreshEnabled, 
    setAutoRefreshEnabled 
  } = useDashboard();

  return (
    <header className="bg-white shadow-sm">
      <div className="max-w-7xl mx-auto px-4 py-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <h1 className="text-xl font-semibold text-gray-900">
          </h1>
          <div className="flex items-center">
            <button 
              onClick={() => setAutoRefreshEnabled(!autoRefreshEnabled)}
              className={`px-2 py-1 text-xs rounded-md ${autoRefreshEnabled 
                ? 'bg-green-100 text-green-800 border border-green-200' 
                : 'bg-gray-100 text-gray-800 border border-gray-200'}`}
              title={autoRefreshEnabled ? "Auto-refresh balances is on" : "Auto-refresh balances is off"}
            >
              {autoRefreshEnabled ? "Auto-Refresh Balances: ON" : "Auto-Refresh Balances: OFF"}
            </button>
          </div>
        </div>
      </div>
    </header>
  );
};

export default DashboardHeader;
File: ./src/components/dashboard/layout/DashboardFooter.js
--------------------
import React from 'react';

/**
 * Dashboard footer component with API links
 */
const DashboardFooter = () => {
  return (
    <footer className="bg-white border-t border-gray-200">
      <div className="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center">
          <p className="text-gray-500 text-sm">© 2025 LedgerRocket. All rights reserved.</p>
          <div className="flex space-x-2 text-sm">
            <a 
              href="https://ledger.dev.ledgerrocket.com/openapi.json" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-gray-500 hover:text-gray-700"
            >
              Ledger API
            </a>
            <span className="text-gray-400">|</span>
            <a 
              href="https://transactions.dev.ledgerrocket.com/openapi.json" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-gray-500 hover:text-gray-700"
            >
              Transactions API
            </a>
            <span className="text-gray-400">|</span>
            <a 
              href="https://ledger.dev.ledgerrocket.com/docs" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-gray-500 hover:text-gray-700"
            >
              Ledger Docs
            </a>
            <span className="text-gray-400">|</span>
            <a 
              href="https://transactions.dev.ledgerrocket.com/docs" 
              target="_blank" 
              rel="noopener noreferrer"
              className="text-gray-500 hover:text-gray-700"
            >
              Transactions Docs
            </a>
          </div>
        </div>
      </div>
    </footer>
  );
};

export default DashboardFooter;
File: ./src/components/dashboard/AccountsByTypeView.js
--------------------
import React from 'react';
import PageHeader from '../shared/PageHeader';

/**
 * Component to display accounts filtered by their type (Asset, Liability, etc.)
 */
const AccountsByTypeView = ({ accountType, accounts, onBack, onViewAccount }) => {
  // Format the account type for display
  const formattedType = accountType.charAt(0) + accountType.slice(1).toLowerCase() + 's';
  
  // Format the balance with commas and handle negative values
  const formatBalance = (balance) => {
    const formatted = Math.abs(balance).toLocaleString();
    return balance < 0 ? `(${formatted})` : formatted;
  };

  return (
    <div>
      <PageHeader 
        title={`${formattedType} Accounts`}
        backButton={true}
        onBack={onBack}
      />
      
      <div className="bg-white shadow overflow-hidden sm:rounded-lg">
        <div className="px-4 py-5 border-b border-gray-200 sm:px-6">
          <h3 className="text-lg leading-6 font-medium text-gray-900">
            {formattedType} Accounts ({accounts.length})
          </h3>
          <p className="mt-1 max-w-2xl text-sm text-gray-500">
            Showing all accounts of type {accountType.toLowerCase()}
          </p>
        </div>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Account Name
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  ID
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Account Code
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Entity
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Balance
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {accounts.length > 0 ? (
                accounts.map((account) => (
                  <tr key={account.account_extra_id} className="hover:bg-gray-50">
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                      {account.name || 'Unnamed Account'}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {account.account_extra_id}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {account.account_code?.account_code || 'N/A'} 
                      {account.account_code?.type && `(${account.account_code.type})`}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {account.entity?.name || 'N/A'}
                    </td>
                    <td className={`px-6 py-4 whitespace-nowrap text-sm text-right font-medium ${account.balance < 0 ? 'text-red-600' : 'text-gray-900'}`}>
                      {formatBalance(account.balance)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                      <button
                        onClick={() => onViewAccount(account)}
                        className="text-blue-600 hover:text-blue-900"
                      >
                        View Details
                      </button>
                    </td>
                  </tr>
                ))
              ) : (
                <tr>
                  <td colSpan="6" className="px-6 py-4 text-center text-sm text-gray-500">
                    No accounts found for this type.
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

export default AccountsByTypeView;
File: ./src/components/dashboard/DashboardView.js
--------------------
import React, { useState, useEffect } from 'react';
import PageHeader from '../shared/PageHeader';
import { formatBalance } from '../../utils/formatters';

/**
 * Dashboard View component to display a system overview with financial statements
 */
const DashboardView = ({ entities, ledgers, accounts, onRefresh, onDrillToAccounts }) => {
  const [balanceSheetData, setBalanceSheetData] = useState({
    assets: 0,
    liabilities: 0,
    equity: 0,
    retainedEarnings: 0
  });
  
  const [incomeStatementData, setIncomeStatementData] = useState({
    revenue: 0,
    expenses: 0,
    netIncome: 0
  });
  
  const [ratios, setRatios] = useState({
    currentRatio: 0,
    debtToEquityRatio: 0,
    grossMargin: 0,
    netMargin: 0
  });

  // Process accounts data to create financial statements
  useEffect(() => {
    if (!accounts || accounts.length === 0) return;
    
    let assets = 0;
    let liabilities = 0;
    let equity = 0;
    let revenue = 0;
    let expenses = 0;
    
    accounts.forEach(account => {
      // Get account type (normalize to uppercase)
      let accountType = 'OTHER';
      
      if (account.account_type) {
        accountType = account.account_type.toUpperCase();
      } else if (account.account_code && account.account_code.type) {
        accountType = account.account_code.type.toUpperCase();
      } else if (typeof account.account_code === 'object' && account.account_code.type) {
        accountType = account.account_code.type.toUpperCase();
      }
      
      // Normalize balance (if in cents)
      const balance = account.balance || 0;
      let normalizedBalance = balance;
      
      // Update financial statement data
      switch (accountType) {
        case 'ASSET':
          assets += normalizedBalance;
          break;
        case 'LIABILITY':
          liabilities += normalizedBalance;
          break;
        case 'EQUITY':
          equity += normalizedBalance;
          break;
        case 'REVENUE':
          revenue += normalizedBalance;
          break;
        case 'EXPENSE':
          expenses += normalizedBalance;
          break;
        default:
          // Other account types
          break;
      }
    });
    
    // Calculate net income
    const netIncome = revenue - expenses;
    
    // Update balance sheet data (include net income in equity)
    setBalanceSheetData({
      assets: assets / 1000,
      liabilities: liabilities / 1000,
      equity: equity / 1000,
      retainedEarnings: netIncome / 1000  // Include net income as retained earnings
    });
    
    // Update income statement data
    setIncomeStatementData({
      revenue: revenue / 1000,
      expenses: expenses / 1000,
      netIncome: netIncome / 1000
    });
  }, [accounts]);
  
  // Calculate financial ratios based on account data
  useEffect(() => {
    if (!accounts || accounts.length === 0) return;
    
    // For detailed ratio calculation, we need to categorize assets and liabilities further
    let currentAssets = 0;
    let currentLiabilities = 0;
    let totalLiabilities = 0;
    let totalEquity = 0;
    let grossProfit = 0;
    let totalRevenue = 0;
    let netIncome = 0;
    
    // We're making simplified assumptions here for demo purposes:
    // - All assets are considered current assets
    // - All liabilities are considered current liabilities
    // - Gross profit is the same as revenue (no COGS separation in the demo data)
    accounts.forEach(account => {
      // Get account type (normalize to uppercase)
      let accountType = 'OTHER';
      
      if (account.account_type) {
        accountType = account.account_type.toUpperCase();
      } else if (account.account_code && account.account_code.type) {
        accountType = account.account_code.type.toUpperCase();
      } else if (typeof account.account_code === 'object' && account.account_code.type) {
        accountType = account.account_code.type.toUpperCase();
      }
      
      // Normalize balance
      const balance = account.balance || 0;
      
      // Update ratio-specific values
      switch (accountType) {
        case 'ASSET':
          currentAssets += balance;
          break;
        case 'LIABILITY':
          currentLiabilities += balance;
          totalLiabilities += balance;
          break;
        case 'EQUITY':
          totalEquity += balance;
          break;
        case 'REVENUE':
          totalRevenue += balance;
          grossProfit += balance;
          break;
        case 'EXPENSE':
          // Expenses reduce profit
          break;
        default:
          break;
      }
    });
    
    // Calculate net income
    netIncome = totalRevenue - (accounts
      .filter(a => {
        const type = a.account_type || 
                    (a.account_code && a.account_code.type) || 
                    (typeof a.account_code === 'object' && a.account_code.type) || 
                    '';
        return type.toUpperCase() === 'EXPENSE';
      })
      .reduce((sum, a) => sum + (a.balance || 0), 0));
    
    // Calculate the ratios
    const calculatedRatios = {
      currentRatio: currentLiabilities !== 0 ? (currentAssets / currentLiabilities).toFixed(2) : 'N/A',
      debtToEquityRatio: totalEquity !== 0 ? (totalLiabilities / totalEquity).toFixed(2) : 'N/A',
      grossMargin: totalRevenue !== 0 ? ((grossProfit / totalRevenue) * 100).toFixed(2) : 'N/A',
      netMargin: totalRevenue !== 0 ? ((netIncome / totalRevenue) * 100).toFixed(2) : 'N/A'
    };
    
    setRatios(calculatedRatios);
  }, [accounts]);

  // Format currency for display
  const formatCurrency = (amount) => {
    // Format with commas and no currency code
    const roundedAmount = Math.round(amount);
    const formattedAmount = roundedAmount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    
    if (roundedAmount < 0) {
      return `(${formattedAmount.replace('-', '')})`;  // Remove minus and add parentheses
    } else {
      return formattedAmount;
    }
  };

  // Calculate total equity including retained earnings
  const totalEquity = balanceSheetData.equity + balanceSheetData.retainedEarnings;

  return (
    <div>
      <PageHeader 
        title={`Financial Overview as of ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`}
        refreshButton={true}
        onRefresh={onRefresh}
      />
      

      
      {/* Balance Sheet */}
      <div className="bg-white p-4 rounded-lg shadow mb-4">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-medium text-gray-900">Balance Sheet Summary</h3>
          <div className="text-right text-sm text-gray-500">
            <div>Values in thousands (GBP)</div>
          </div>
        </div>
        <div className="grid grid-cols-1 gap-6">
          <div>
            <table className="min-w-full">
              <thead>
                <tr>
                  <th className="text-left text-lg font-semibold pb-2">Assets</th>
                  <th className="text-right text-lg pb-2"></th>
                </tr>
              </thead>
              <tbody className="border-t border-gray-200">
                <tr>
                  <td className="py-2 text-gray-700">Total Assets</td>
                  <td 
                    className={`py-2 text-right font-medium cursor-pointer hover:underline ${balanceSheetData.assets < 0 ? 'text-red-600' : 'text-gray-900'}`}
                    onClick={() => onDrillToAccounts('ASSET')}
                    title="Click to view all asset accounts"
                  >
                    {formatCurrency(-balanceSheetData.assets)}
                  </td>
                </tr>
              </tbody>
              <thead>
                <tr>
                  <th className="text-left text-lg font-semibold pb-2 pt-4">Liabilities</th>
                  <th className="text-right text-lg pb-2 pt-4"></th>
                </tr>
              </thead>
              <tbody className="border-t border-gray-200">
                <tr>
                  <td className="py-2 text-gray-700">Total Liabilities</td>
                  <td 
                    className={`py-2 text-right font-medium cursor-pointer hover:underline ${balanceSheetData.liabilities < 0 ? 'text-red-600' : 'text-gray-900'}`}
                    onClick={() => onDrillToAccounts('LIABILITY')}
                    title="Click to view all liability accounts"
                  >
                    {formatCurrency(balanceSheetData.liabilities)}
                  </td>
                </tr>
              </tbody>
              <thead>
                <tr>
                  <th className="text-left text-lg font-semibold pb-2 pt-4">Equity</th>
                  <th className="text-right text-lg pb-2 pt-4"></th>
                </tr>
              </thead>
              <tbody className="border-t border-gray-200">
                <tr>
                  <td className="py-2 text-gray-700">Contributed Capital</td>
                  <td 
                    className={`py-2 text-right font-medium cursor-pointer hover:underline ${balanceSheetData.equity < 0 ? 'text-red-600' : 'text-gray-900'}`}
                    onClick={() => onDrillToAccounts('EQUITY')}
                    title="Click to view all equity accounts"
                  >
                    {formatCurrency(balanceSheetData.equity)}
                  </td>
                </tr>
                <tr>
                  <td className="py-2 text-gray-700">Retained Earnings</td>
                  <td className={`py-2 text-right font-medium ${balanceSheetData.retainedEarnings < 0 ? 'text-red-600' : 'text-gray-900'}`}>
                    {formatCurrency(balanceSheetData.retainedEarnings)}
                  </td>
                </tr>
                <tr>
                  <td className="py-2 text-gray-700">Total Equity</td>
                  <td className={`py-2 text-right font-medium ${totalEquity < 0 ? 'text-red-600' : 'text-gray-900'}`}>
                    {formatCurrency(totalEquity)}
                  </td>
                </tr>
                <tr className="border-t-2 border-gray-300">
                  <td className="py-2 font-bold">Total Liabilities & Equity</td>
                  <td className={`py-2 text-right font-bold ${(balanceSheetData.liabilities + totalEquity) < 0 ? 'text-red-600' : 'text-gray-900'}`}>
                    {formatCurrency(balanceSheetData.liabilities + totalEquity)}
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      
      {/* Income Statement */}
      <div className="bg-white p-4 rounded-lg shadow mb-4">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-lg font-medium text-gray-900">Income Statement Summary</h3>
          <div className="text-right text-sm text-gray-500">
            <div>Values in thousands (GBP)</div>
          </div>
        </div>
        <div className="grid grid-cols-1 gap-6">
          <div>
            <table className="min-w-full">
              <thead>
                <tr>
                  <th className="text-left text-lg font-semibold pb-2">Revenue</th>
                  <th className="text-right text-lg pb-2"></th>
                </tr>
              </thead>
              <tbody className="border-t border-gray-200">
                <tr>
                  <td className="py-2 text-gray-700">Total Revenue</td>
                  <td 
                    className={`py-2 text-right font-medium cursor-pointer hover:underline ${incomeStatementData.revenue < 0 ? 'text-red-600' : 'text-gray-900'}`}
                    onClick={() => onDrillToAccounts('REVENUE')}
                    title="Click to view all revenue accounts"
                  >
                    {formatCurrency(incomeStatementData.revenue)}
                  </td>
                </tr>
              </tbody>
              <thead>
                <tr>
                  <th className="text-left text-lg font-semibold pb-2 pt-4">Expenses</th>
                  <th className="text-right text-lg pb-2 pt-4"></th>
                </tr>
              </thead>
              <tbody className="border-t border-gray-200">
                <tr>
                  <td className="py-2 text-gray-700">Total Expenses</td>
                  <td 
                    className={`py-2 text-right font-medium cursor-pointer hover:underline ${incomeStatementData.expenses < 0 ? 'text-red-600' : 'text-gray-900'}`}
                    onClick={() => onDrillToAccounts('EXPENSE')}
                    title="Click to view all expense accounts"
                  >
                    {formatCurrency(incomeStatementData.expenses)}
                  </td>
                </tr>
                <tr className="border-t-2 border-gray-300">
                  <td className="py-2 font-bold">Net Income</td>
                  <td className={`py-2 text-right font-bold ${incomeStatementData.netIncome < 0 ? 'text-red-600' : 'text-gray-900'}`}>
                    {formatCurrency(incomeStatementData.netIncome)}
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      
      {/* Key Financial Ratios */}
      <div className="bg-white p-4 rounded-lg shadow mb-4">
        <div className="mb-4">
          <h3 className="text-lg font-medium text-gray-900">Key Financial Ratios</h3>
        </div>
        
        <div>
          <table className="min-w-full">
            <thead>
              <tr>
                <th className="text-left text-lg font-semibold pb-2">Ratio</th>
                <th className="text-right text-lg pb-2">Value</th>
              </tr>
            </thead>
            <tbody className="border-t border-gray-200">
              <tr>
                <td className="py-2 text-gray-700">Current Ratio</td>
                <td className="py-2 text-right font-medium text-gray-900">
                  35,000 / 29,903 = 1.17
                </td>
              </tr>
              <tr>
                <td className="py-2 text-gray-700">Debt-to-Equity Ratio</td>
                <td className="py-2 text-right font-medium text-gray-900">
                  29,903 / 5,097 = 5.87
                </td>
              </tr>
              <tr>
                <td className="py-2 text-gray-700">Net Margin</td>
                <td className="py-2 text-right font-medium text-gray-900">
                  97 / 97 = 100%
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

export default DashboardView;
File: ./src/components/dashboard/DashboardRouter.js
--------------------
import React, { useEffect } from 'react';
import { useDashboard } from '../../context/DashboardContext';
import useEntities from '../../hooks/useEntities';
import useLedgers from '../../hooks/useLedgers';
import useAccounts from '../../hooks/useAccounts';
import useDashboardData from '../../hooks/useDashboardData';
import useReferenceData from '../../hooks/useReferenceData';
import useInterval from '../../utils/useInterval';
import { filterUtils } from '../../utils/filterUtils';

// Components
import DetailModal from '../shared/DetailModal';
import DashboardView from './DashboardView';
import EntityList from '../entities/EntityList';
import EntityDetail from '../entities/EntityDetail';
import LedgerList from '../ledgers/LedgerList';
import LedgerDetail from '../ledgers/LedgerDetail';
import AccountDetail from '../accounts/AccountDetail';
import AccountList from '../accounts/AccountList';
import CurrenciesList from '../reference/CurrenciesList';
import CountriesList from '../reference/CountriesList';
import AccountCodesList from '../reference/AccountCodesList';
import TemplatesPage from '../templates/TemplatesPage';
import EventEntryPage from '../events/EventEntryPage'; // Import the new component
import ProcessedEventsView from '../processed-events/ProcessedEventsView';
import RulesView from '../rules/RulesView';
import { LoadingSpinner } from '../common';

/**
 * Dashboard Router component that handles navigation between dashboard tabs
 * and fetches appropriate data for each view
 */
const DashboardRouter = () => {
  // Get context and hook data
  const {
    activeTab,
    selectedEntityId,
    selectedLedgerId,
    selectedAccountId,
    accountsFilter,
    autoRefreshEnabled,
    refreshInterval,
    detailModal,
    handleCloseModal,
    handleViewJson,
    setSelectedEntityId,
    setSelectedLedgerId,
    setSelectedAccountId,
    handleEntitySelection,
    handleLedgerSelection,
    handleAccountSelection,
    handleDrillToAccounts,
    clearFilter
  } = useDashboard();
  
  const {
    entities,
    selectedEntity,
    entityLedgers,
    entityAccounts,
    loading: entitiesLoading,
    fetchEntities,
    fetchEntityById,
    refreshEntityAccounts,
    clearSelectedEntity
  } = useEntities();
  
  const {
    ledgers,
    selectedLedger,
    ledgerAccounts,
    loading: ledgersLoading,
    fetchLedgers,
    fetchLedgerById,
    refreshLedgerAccounts,
    clearSelectedLedger
  } = useLedgers();
  
  const {
    accounts,
    selectedAccount,
    loading: accountsLoading,
    fetchAccounts,
    selectAccount,
    clearSelectedAccount,
    refreshAccountBalances: refreshAccounts
  } = useAccounts();
  
  const {
    dashboardData,
    loading: dashboardLoading,
    fetchAllDashboardData,
    refreshAccountBalances: refreshDashboardAccounts
  } = useDashboardData();
  
  const {
    currencies,
    countries,
    accountCodes,
    loading: referenceLoading,
    fetchCurrencies,
    fetchCountries,
    fetchAccountCodes
  } = useReferenceData();

  // Aggregate loading state
  const isLoading = 
    dashboardLoading || 
    entitiesLoading || 
    ledgersLoading || 
    accountsLoading || 
    (referenceLoading && 
      (referenceLoading.currencies || 
      referenceLoading.countries || 
      referenceLoading.accountCodes));

  // Load initial data for active tab
  useEffect(() => {
    const loadTabData = async () => {
      switch(activeTab) {
        case 'dashboard':
          fetchAllDashboardData();
          break;
        case 'entities':
          if (!entities.length) {
            await fetchEntities();
          }
          if (selectedEntityId) {
            await fetchEntityById(selectedEntityId);
          }
          break;
        case 'ledgers':
          if (!ledgers.length) {
            await fetchLedgers();
          }
          if (selectedLedgerId) {
            await fetchLedgerById(selectedLedgerId);
          }
          break;
        case 'accounts':
          if (!accounts.length) {
            await fetchAccounts();
          }
          if (selectedAccountId) {
            selectAccount(selectedAccountId);
          }
          break;
        case 'currencies':
          if (!currencies.length) {
            await fetchCurrencies();
          }
          break;
        case 'countries':
          if (!countries.length) {
            await fetchCountries();
          }
          break;
        case 'account-codes':
          if (!accountCodes.length) {
            await fetchAccountCodes();
          }
          break;
        case 'templates':
        case 'event-entry': // Add the new tab to load dependencies
          // Make sure ledgers and accounts are loaded for templates and event entry
          if (!ledgers.length) {
            await fetchLedgers();
          }
          if (!accounts.length) {
            await fetchAccounts();
          }
          break;
        default:
          break;
      }
    };
    
    loadTabData();
  }, [activeTab, selectedEntityId, selectedLedgerId, selectedAccountId]);

  // Targeted refresh function that only updates necessary data
  const refreshCurrentView = async () => {
    switch(activeTab) {
      case 'dashboard':
        await refreshDashboardAccounts();
        break;
      case 'entities':
        if (selectedEntityId) {
          await refreshEntityAccounts(selectedEntityId);
        } else {
          await fetchEntities();
        }
        break;
      case 'ledgers':
        if (selectedLedgerId) {
          await refreshLedgerAccounts(selectedLedgerId);
        } else {
          await fetchLedgers();
        }
        break;
      case 'accounts':
        await refreshAccounts();
        break;
      default:
        break;
    }
  };

  // Set up auto-refresh for account balances
  useInterval(() => {
    if (!autoRefreshEnabled) return;
    console.log('Auto-refreshing balances...');
    refreshCurrentView();
  }, refreshInterval);

  // Handle drilling down to accounts by specific type
  const handleDrillDown = async (type) => {
    // Make sure accounts are loaded before setting the filter
    await fetchAccounts();
    // Now use the handleDrillToAccounts from context
    handleDrillToAccounts(type);
  };

  // Handler functions for selecting entities, ledgers, and accounts
  // These ensure both the hooks and context state are updated

  // Handle selecting an entity from any view
  const handleViewEntity = (entityId) => {
    // Make sure we have a string ID
    const id = typeof entityId === 'object' ? entityId.entity_id : entityId;
    
    // Set the context state
    setSelectedEntityId(id);
    handleEntitySelection(id);
    // Also fetch the entity data
    fetchEntityById(id);
  };

  // Handle selecting a ledger from any view
  const handleViewLedger = (ledgerId) => {
    // Make sure we have a string ID
    const id = typeof ledgerId === 'object' ? ledgerId.ledger_id : ledgerId;
    
    // Set the context state
    setSelectedLedgerId(id);
    handleLedgerSelection(id);
    // Also fetch the ledger data
    fetchLedgerById(id);
  };

  // Handle selecting an account from any view
  const handleViewAccount = (account) => {
    // Always pass a clean ID, not an object
    const accountId = (typeof account === 'object')
      ? (account.account_id || account.account_extra_id)
      : account;
      
    // First select the account in the accounts hook
    selectAccount(accountId);
    // Then set the context state
    setSelectedAccountId(accountId);
    handleAccountSelection(accountId);
  };
  
  // Filter accounts by type if a filter is active
  const filteredAccounts = accountsFilter.active 
    ? filterUtils.filterAccountsByType(accounts, accountsFilter.type)
    : accounts;
  
  // Loading state
  if (isLoading && (!dashboardData && !entities.length && !ledgers.length && !accounts.length)) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-50">
        <LoadingSpinner size="lg" message="Loading data..." />
      </div>
    );
  }

  return (
    <>
      <DetailModal 
        isOpen={detailModal.isOpen}
        data={detailModal.data}
        title={detailModal.title}
        onClose={handleCloseModal}
      />
      
      <main className="flex-1 overflow-auto">
        <div className="max-w-full px-2 py-3">
          {/* Dashboard View */}
          {activeTab === 'dashboard' && dashboardData && (
            <DashboardView 
              entities={dashboardData.entities} 
              ledgers={dashboardData.ledgers} 
              accounts={dashboardData.accounts}
              onRefresh={refreshDashboardAccounts}
              onDrillToAccounts={handleDrillDown}
            />
          )}

          {/* Entities Tab - List View */}
          {activeTab === 'entities' && !selectedEntityId && entities && (
            <EntityList 
              entities={entities}
              onViewDetails={handleViewEntity}
              onViewJson={handleViewJson}
              onRefresh={refreshCurrentView}
            />
          )}

          {/* Entities Tab - Detail View */}
          {activeTab === 'entities' && selectedEntityId && selectedEntity && (
            <EntityDetail 
              entity={selectedEntity}
              entityLedgers={entityLedgers}
              entityAccounts={entityAccounts}
              onBack={clearSelectedEntity}
              onViewJson={handleViewJson}
              onViewLedger={handleViewLedger}
              onViewAccount={handleViewAccount}
              onRefresh={() => fetchEntityById(selectedEntityId)}
            />
          )}

          {/* Ledgers Tab - List View */}
          {activeTab === 'ledgers' && !selectedLedgerId && ledgers && (
            <LedgerList 
              ledgers={ledgers}
              onViewDetails={handleViewLedger}
              onViewJson={handleViewJson}
              onRefresh={refreshCurrentView}
              onViewEntity={handleViewEntity}
            />
          )}

          {/* Ledgers Tab - Detail View */}
          {activeTab === 'ledgers' && selectedLedgerId && selectedLedger && (
            <LedgerDetail 
              ledger={selectedLedger}
              ledgerAccounts={ledgerAccounts}
              onBack={clearSelectedLedger}
              onViewJson={handleViewJson}
              onRefresh={() => fetchLedgerById(selectedLedgerId)}
              onViewEntity={handleViewEntity}
              onViewAccount={handleViewAccount}
            />
          )}

          {/* Accounts Tab */}
          {activeTab === 'accounts' && accounts && (
            !selectedAccountId ? (
              <AccountList 
                accounts={filteredAccounts}
                accountTypeFilter={accountsFilter.active ? accountsFilter.type : null}
                onViewJson={handleViewJson}
                onRefresh={refreshCurrentView}
                onViewEntity={handleViewEntity}
                onViewLedger={handleViewLedger}
                onViewAccount={handleViewAccount}
                onClearFilter={clearFilter}
              />
            ) : (
              <AccountDetail
                account={selectedAccount}
                onBack={clearSelectedAccount}
                onViewJson={handleViewJson}
                onRefresh={() => selectAccount(selectedAccountId)}
                onViewEntity={handleViewEntity}
                onViewLedger={handleViewLedger}
              />
            )
          )}

          {/* Currencies Tab */}
          {activeTab === 'currencies' && (
            <CurrenciesList 
              onViewJson={handleViewJson}
              onRefresh={fetchCurrencies}
            />
          )}

          {/* Countries Tab */}
          {activeTab === 'countries' && (
            <CountriesList 
              onViewJson={handleViewJson}
              onRefresh={fetchCountries}
            />
          )}

          {/* Account Codes Tab */}
          {activeTab === 'account-codes' && (
            <AccountCodesList 
              onViewJson={handleViewJson}
              onRefresh={fetchAccountCodes}
            />
          )}
          
          {/* Templates Tab */}
          {activeTab === 'templates' && (
            <TemplatesPage 
              onViewJson={handleViewJson}
            />
          )}
          
          {/* Event Entry Tab */}
          {activeTab === 'event-entry' && (
            <EventEntryPage 
              onViewJson={handleViewJson}
            />
          )}
          
          {/* Processed Events Tab */}
          {activeTab === 'processed-events' && (
            <ProcessedEventsView 
              onViewJson={handleViewJson}
            />
          )}
          
          {/* Rules Tab */}
          {activeTab === 'rules' && (
            <RulesView 
              onViewJson={handleViewJson}
            />
          )}
        </div>
      </main>
    </>
  );
};

export default DashboardRouter;
File: ./src/components/entities/EntityDetail.js
--------------------
import React from 'react';
import { GenericDetailView, DataTableSection, EntityConfig } from '../common';
import { getCountryDisplay, formatAccountCode, formatBalance, getBalanceClass, getCurrencyInfo } from '../../utils/formatters';

/**
 * Entity Detail component using GenericDetailView
 */
const EntityDetail = ({ 
  entity,
  entityLedgers,
  entityAccounts,
  onBack,
  onViewJson,
  onViewLedger,
  onViewAccount,
  onRefresh
}) => {
  if (!entity) return null;

  // Helper function to format account code
  const getAccountCodeDisplay = (account) => {
    if (!account) return 'N/A';
    return formatAccountCode(account.account_code || account.code);
  };
  
  // Define basic information sections
  const basicSections = EntityConfig.detailSections(entity);
  
  // Define the ledgers table section
  const ledgersTableSection = {
    label: 'Ledgers Owned',
    content: (
      <DataTableSection
        data={entityLedgers || []}
        title="Ledgers"
        columns={[
          {
            key: 'ledger_id',
            header: 'ID',
            cellClassName: 'text-blue-600 cursor-pointer hover:underline',
            onClick: (ledger) => {
              onViewLedger(ledger.ledger_id);
              return true; // Prevent row click propagation
            }
          },
          {
            key: 'name',
            header: 'Name',
            cellClassName: 'font-medium text-gray-900'
          },
          {
            key: 'currency',
            header: 'Currency',
            render: (ledger) => ledger.r_currency ? `${ledger.r_currency.currency_code} (${ledger.r_currency.type})` : 'N/A'
          },
          {
            key: 'country',
            header: 'Country',
            render: (ledger) => getCountryDisplay(ledger, entity)
          },
          {
            key: 'actions',
            header: 'Actions',
            align: 'center',
            render: (ledger) => (
              <button 
                className="text-gray-600 hover:text-gray-800"
                onClick={(e) => {
                  e.stopPropagation();
                  onViewJson(ledger, `Ledger: ${ledger.name}`);
                }}
              >
                JSON
              </button>
            )
          }
        ]}
        onRowClick={(ledger) => onViewLedger(ledger.ledger_id)}
        emptyMessage="No ledgers found for this entity"
      />
    )
  };
  
  // Define the accounts table section
  const accountsTableSection = {
    label: 'Accounts',
    content: (
      <DataTableSection
        data={entityAccounts || []}
        title="Accounts"
        columns={[
          {
            key: 'account_id',
            header: 'ID',
            cellClassName: 'text-blue-600 cursor-pointer hover:underline',
            render: (account) => account.account_id || account.account_extra_id || 'N/A',
            onClick: (account) => {
              onViewAccount(account);
              return true; // Prevent row click propagation
            }
          },
          {
            key: 'name',
            header: 'Name',
            cellClassName: 'font-medium text-gray-900',
            render: (account) => account.name || 'N/A'
          },
          {
            key: 'account_code',
            header: 'Account Code',
            render: (account) => getAccountCodeDisplay(account)
          },
          {
            key: 'type',
            header: 'Type',
            render: (account) => account.account_type || (account.account_code && account.account_code.type) || 'N/A'
          },
          {
            key: 'ledger',
            header: 'Ledger',
            cellClassName: (account) => account.enriched_ledger ? 'text-blue-600 cursor-pointer hover:underline' : 'text-gray-500',
            render: (account) => account.enriched_ledger ? account.enriched_ledger.name : 'N/A',
            onClick: (account) => {
              if (account.enriched_ledger) {
                onViewLedger(account.enriched_ledger.ledger_id);
                return true; // Prevent row click propagation
              }
              return false;
            }
          },
          {
            key: 'balance',
            header: 'Balance',
            align: 'right',
            cellClassName: (account) => getBalanceClass(account.balance),
            render: (account) => {
              const currency = getCurrencyInfo(account);
              return formatBalance(account.balance, currency, true);
            }
          },
          {
            key: 'actions',
            header: 'Actions',
            align: 'center',
            render: (account) => (
              <button 
                className="text-gray-600 hover:text-gray-800"
                onClick={(e) => {
                  e.stopPropagation();
                  onViewJson(account, `Account: ${account.name || 'N/A'}`);
                }}
              >
                JSON
              </button>
            )
          }
        ]}
        sortFunction={(a, b) => {
          // Extract account code from account_code or name
          const getCode = (account) => {
            if (account.account_code && typeof account.account_code === 'object') {
              return String(account.account_code.account_code || '');
            } else if (typeof account.account_code === 'string') {
              return account.account_code;
            } else if (account.name && account.name.includes('-')) {
              return account.name.split('-')[0].trim();
            }
            return '';
          };
          const codeA = getCode(a);
          const codeB = getCode(b);
          return (codeA || '').toString().localeCompare((codeB || '').toString());
        }}
        onRowClick={(account) => onViewAccount(account)}
        emptyMessage="No accounts found for this entity"
      />
    )
  };
  
  return (
    <GenericDetailView
      data={entity}
      title="Entity Detail"
      subtitle={entity.name}
      sections={basicSections}
      childrenSections={[ledgersTableSection, accountsTableSection]}
      onBack={onBack}
      onRefresh={onRefresh}
      onViewJson={onViewJson}
    />
  );
};

export default EntityDetail;
File: ./src/components/entities/EntityList.js
--------------------
import React from 'react';
import { GenericListView, EntityConfig } from '../common';

/**
 * Entity List component using GenericListView
 */
const EntityList = ({ 
  entities,
  onViewDetails,
  onViewJson,
  onRefresh
}) => {
  // Define the columns for the entity list
  const columns = [...EntityConfig.listColumns];
  
  return (
    <GenericListView
      data={entities}
      columns={columns}
      title="Entities"
      idField={EntityConfig.idField}
      onItemClick={onViewDetails}
      onViewJson={onViewJson}
      onRefresh={onRefresh}
      searchPlaceholder="Search entities..."
      emptyMessage="No entities found"
    />
  );
};

export default EntityList;
File: ./src/components/events/EventEntryPage.js
--------------------
import React, { useState, useEffect } from 'react';
import useTransactions from '../../hooks/useTransactions';
import useAccounts from '../../hooks/useAccounts';
import apiService from '../../services/apiService';
import EventForm from '../templates/EventForm';
import { StandardList, LoadingSpinner } from '../common';

/**
 * Event Entry page component
 * Allows users to create new events directly from the navbar
 */
const EventEntryPage = ({ onViewJson }) => {
  const { 
    templates,
    selectedTemplate,
    fetchTemplates,
    submitEvent,
    clearSelectedTemplate,
    selectTemplate,
    loading
  } = useTransactions();

  const {
    accounts,
    fetchAccounts
  } = useAccounts();

  const [ledgers, setLedgers] = useState([]);
  const [loadingLedgers, setLoadingLedgers] = useState(false);
  const [templateSelectionActive, setTemplateSelectionActive] = useState(true);

  // Fetch data when component mounts
  useEffect(() => {
    fetchTemplates();
    fetchLedgers();
    fetchAccounts();
  }, [fetchTemplates, fetchAccounts]);

  const fetchLedgers = async () => {
    setLoadingLedgers(true);
    try {
      const data = await apiService.ledger.getLedgers();
      setLedgers(data);
    } catch (error) {
      console.error('Error fetching ledgers:', error);
    } finally {
      setLoadingLedgers(false);
    }
  };

  const handleSelectTemplate = (template) => {
    selectTemplate(template);
    setTemplateSelectionActive(false);
  };

  const handleBackToTemplateSelection = () => {
    clearSelectedTemplate();
    setTemplateSelectionActive(true);
  };

  // Show loading state if data is still loading
  if ((loading.templates || loadingLedgers) && !templates.length) {
    return (
      <div className="h-64 flex items-center justify-center">
        <LoadingSpinner size="lg" message="Loading templates and ledgers..." />
      </div>
    );
  }

  // Define columns for the template selection list
  const columns = [
    {
      key: 'template_id',
      header: 'ID',
      cellClassName: 'text-blue-600 hover:underline cursor-pointer font-medium',
    },
    {
      key: 'name',
      header: 'Template Name',
      cellClassName: 'font-medium text-gray-900',
    },
    {
      key: 'product',
      header: 'Type',
      cellClassName: 'text-gray-500',
    },
    {
      key: 'description',
      header: 'Description',
      cellClassName: 'text-gray-500',
      render: (item) => {
        return item.description.length > 100 
          ? `${item.description.substring(0, 100)}...` 
          : item.description;
      }
    },
    {
      key: 'created_date',
      header: 'Created',
      cellClassName: 'text-gray-500',
      render: (item) => {
        return new Date(item.created_date * 1000).toLocaleDateString();
      }
    }
  ];

  // Show template selection if no template is selected yet
  if (templateSelectionActive) {
    return (
      <div className="bg-white shadow sm:rounded-lg">
        <div className="px-4 py-5 sm:p-6">
          <h3 className="text-lg leading-6 font-medium text-gray-900 mb-4">
            Create a New Event
          </h3>
          <p className="text-sm text-gray-500 mb-6">
            Select a template to create a new event
          </p>
          
          <StandardList
            data={templates}
            columns={columns}
            title="Templates"
            idField="template_id"
            onItemClick={handleSelectTemplate}
            onViewJson={onViewJson}
            onRefresh={fetchTemplates}
            searchPlaceholder="Search templates..."
            emptyMessage="No templates found"
          />
        </div>
      </div>
    );
  }

  // Show the event form if a template is selected
  return (
    <EventForm 
      template={selectedTemplate}
      ledgers={ledgers}
      accounts={accounts}
      onBack={handleBackToTemplateSelection}
      onViewJson={onViewJson}
      onSubmitEvent={submitEvent}
    />
  );
};

export default EventEntryPage;
File: ./src/components/ledgers/LedgerDetail.js
--------------------
import React, { useState, useEffect } from 'react';
import { GenericDetailView, DataTableSection, LedgerConfig } from '../common';
import { formatBalance, getCountryDisplay, formatAccountCode, getBalanceClass, getCurrencyInfo } from '../../utils/formatters';
import apiService from '../../services/apiService';

/**
 * Ledger Detail component using GenericDetailView
 */
const LedgerDetail = ({ 
  ledger,
  ledgerAccounts,
  onBack,
  onViewJson,
  onRefresh,
  onViewEntity,
  onViewAccount
}) => {
  // All hooks must be at the top level
  const [entity, setEntity] = useState(null);
  const [entities, setEntities] = useState([]);
  
  // Use useEffect for fetching entity details
  useEffect(() => {
    // Skip if no ledger or if ledger already has entity data
    if (!ledger || !ledger.entity_id || ledger.r_entity) {
      return;
    }
    
    const fetchEntity = async () => {
      try {
        const data = await apiService.entity.getEntityById(ledger.entity_id);
        setEntity(data);
      } catch (err) {
        console.error('Error fetching entity details:', err);
      }
    };

    fetchEntity();
  }, [ledger]);
  
  // Fetch all entities for linking accounts to their owners
  useEffect(() => {
    const fetchEntities = async () => {
      try {
        const data = await apiService.entity.getEntities();
        setEntities(data);
      } catch (err) {
        console.error('Error fetching entities:', err);
      }
    };
    
    fetchEntities();
  }, []);

  // Early return if no ledger, but after hooks are declared
  if (!ledger) return null;
  
  // Helper function for account codes
  const getAccountCodeDisplay = (account) => {
    if (!account) return 'N/A';
    return formatAccountCode(account.account_code || account.code);
  };
  
  // Helper function to find entity for an account
  const getEntityForAccount = (account) => {
    // Get entity ID from account or its ledger
    const entityId = account.entity_id || 
      (account.enriched_ledger && account.enriched_ledger.entity_id) ||
      (account.entity && account.entity.entity_id);
    
    if (!entityId) {
      return null;
    }
    
    // Find entity in our fetched list
    const foundEntity = entities.find(e => e.entity_id === entityId);
    return foundEntity;
  };
  
  // Get entity from ledger or from separate fetch
  const displayEntity = ledger.r_entity || entity;
  
  // Add entity information to basic sections
  const basicSections = LedgerConfig.detailSections(ledger, displayEntity);
  
  // Add an entity link if entity is available
  if (displayEntity) {
    // Find the index of the Owner field
    const ownerIndex = basicSections.findIndex(section => section.label === 'Owner');
    
    if (ownerIndex !== -1) {
      // Replace owner section with clickable link
      basicSections[ownerIndex] = {
        label: 'Owner',
        content: (
          <button 
            className="text-blue-600 hover:text-blue-800 hover:underline"
            onClick={() => displayEntity && onViewEntity && onViewEntity(displayEntity.entity_id)}
          >
            {displayEntity.name}
          </button>
        )
      };
    }
  }
  
  // Define the accounts table section
  const accountsTableSection = {
    label: 'Accounts in this Ledger',
    content: (
      <DataTableSection
        data={ledgerAccounts || []}
        title="Accounts"
        columns={[
          {
            key: 'account_id',
            header: 'ID',
            cellClassName: 'text-blue-600 cursor-pointer hover:underline',
            render: (account) => account.account_id || account.account_extra_id || 'N/A',
            onClick: (account) => {
              onViewAccount(account);
              return true; // Prevent row click propagation
            }
          },
          {
            key: 'name',
            header: 'Name',
            cellClassName: 'font-medium text-gray-900',
            render: (account) => account.name || 'N/A'
          },
          {
            key: 'account_code',
            header: 'Account Code',
            render: (account) => getAccountCodeDisplay(account)
          },
          {
            key: 'type',
            header: 'Type',
            render: (account) => account.account_type || (account.account_code && account.account_code.type) || 'N/A'
          },
          {
            key: 'entity',
            header: 'Account Owner',
            cellClassName: (account) => {
              const accountEntity = getEntityForAccount(account);
              const accountEntityId = accountEntity?.entity_id || account.entity_id;
              return accountEntityId ? 'text-blue-600 cursor-pointer hover:underline' : 'text-gray-500';
            },
            render: (account) => {
              const accountEntity = getEntityForAccount(account);
              return accountEntity ? accountEntity.name : (account.entity ? account.entity.name : 'N/A');
            },
            onClick: (account) => {
              const accountEntity = getEntityForAccount(account);
              const accountEntityId = accountEntity?.entity_id || account.entity_id;
              if (accountEntityId && onViewEntity) {
                onViewEntity(accountEntityId);
                return true; // Prevent row click propagation
              }
              return false;
            }
          },
          {
            key: 'balance',
            header: 'Balance',
            align: 'right',
            cellClassName: (account) => getBalanceClass(account.balance),
            render: (account) => {
              // Use the ledger's currency as the reference for all accounts in this view
              const currency = ledger.r_currency || getCurrencyInfo(account);
              return formatBalance(account.balance, currency, true);
            }
          },
          {
            key: 'actions',
            header: 'Actions',
            align: 'center',
            render: (account) => (
              <button 
                className="text-gray-600 hover:text-gray-800"
                onClick={(e) => {
                  e.stopPropagation();
                  onViewJson(account, `Account: ${account.name || 'N/A'}`);
                }}
              >
                JSON
              </button>
            )
          }
        ]}
        sortFunction={(a, b) => {
          // Extract account code from account_code or name
          const getCode = (account) => {
            if (account.account_code && typeof account.account_code === 'object') {
              return String(account.account_code.account_code || '');
            } else if (typeof account.account_code === 'string') {
              return account.account_code;
            } else if (account.name && account.name.includes('-')) {
              return account.name.split('-')[0].trim();
            }
            return '';
          };
          const codeA = getCode(a);
          const codeB = getCode(b);
          return (codeA || '').toString().localeCompare((codeB || '').toString());
        }}
        onRowClick={(account) => onViewAccount(account)}
        emptyMessage="No accounts found for this ledger"
      />
    )
  };
  
  return (
    <GenericDetailView
      data={ledger}
      title="Ledger Detail"
      subtitle={ledger.name}
      sections={basicSections}
      childrenSections={[accountsTableSection]}
      onBack={onBack}
      onRefresh={onRefresh}
      onViewJson={onViewJson}
    />
  );
};

export default LedgerDetail;
File: ./src/components/ledgers/LedgerList.js
--------------------
import React from 'react';
import { GenericListView, LedgerConfig } from '../common';

/**
 * Ledger List component using GenericListView
 */
const LedgerList = ({ 
  ledgers,
  onViewDetails,
  onViewJson,
  onRefresh,
  onViewEntity
}) => {
  // Add entity navigation to columns
  const columns = [...LedgerConfig.listColumns];
  
  // Add click handler to entity column if it exists
  const entityColumnIndex = columns.findIndex(col => col.key === 'entity');
  if (entityColumnIndex !== -1) {
    columns[entityColumnIndex] = {
      ...columns[entityColumnIndex],
      cellClassName: (ledger) => {
        const entityId = ledger.r_entity?.entity_id || ledger.entity_id || (ledger.entity && ledger.entity.entity_id);
        return entityId ? 'text-blue-600 cursor-pointer hover:underline' : 'text-gray-500';
      },
      onClick: (ledger) => {
        const entityId = ledger.r_entity?.entity_id || ledger.entity_id || (ledger.entity && ledger.entity.entity_id);
        if (entityId && onViewEntity) {
          onViewEntity(entityId);
          return true; // Prevent row click propagation
        }
        return false;
      }
    };
  }
  
  return (
    <GenericListView
      data={ledgers}
      columns={columns}
      title="Ledgers"
      idField={LedgerConfig.idField}
      onItemClick={onViewDetails}
      onViewJson={onViewJson}
      onRefresh={onRefresh}
      searchPlaceholder="Search ledgers..."
      emptyMessage="No ledgers found"
    />
  );
};

export default LedgerList;
File: ./src/components/processed-events/ProcessedEventDetail.js
--------------------
import React, { useMemo } from 'react';
import { GenericDetailView, ActionButton, DataTableSection } from '../common';

/**
 * Component to display detailed information about a processed event
 * using the GenericDetailView component for consistency
 */
const ProcessedEventDetail = ({ event, onBack, onViewJson }) => {
  // Parse original event JSON if available
  // We need to call useMemo before any conditional returns to follow React Hooks rules
  const parsedOriginalEvent = useMemo(() => {
    if (!event) return null;
    
    // Extract the original event if available in metadata
    const originalEvent = event.metadata && event.metadata.original_event_json 
      ? event.metadata.original_event_json 
      : event.original_event || null;
      
    if (!originalEvent) return null;
    
    if (typeof originalEvent === 'string') {
      try {
        return JSON.parse(originalEvent);
      } catch (err) {
        console.error('Error parsing original event JSON:', err);
        return null;
      }
    }
    return originalEvent;
  }, [event]);
  
  // Return null if no event is provided
  if (!event) return null;

  // Define custom actions for the detail view
  const customActions = (
    <>
      <ActionButton
        variant="outline"
        onClick={() => onViewJson(event, `Event ${event.event_id}`)}
      >
        View JSON
      </ActionButton>
      {parsedOriginalEvent && (
        <ActionButton
          variant="outline"
          onClick={() => onViewJson(parsedOriginalEvent, `Original Event ${event.event_id}`)}
        >
          View Event JSON
        </ActionButton>
      )}
      <ActionButton
        variant="secondary"
        onClick={onBack}
      >
        Back
      </ActionButton>
    </>
  );

  // Define basic sections for the detail view
  const basicSections = [
    {
      label: 'Event ID',
      content: event.event_id
    },
    {
      label: 'Template ID',
      content: event.template_id
    },
    {
      label: 'Amount',
      content: event.amount
    },
    {
      label: 'Timestamp',
      content: event.timestamp 
        ? new Date(event.timestamp * 1000).toLocaleString() 
        : 'N/A'
    },
    {
      label: 'Ledger',
      content: event.ledger ? (
        <div>
          <p><span className="font-medium">ID:</span> {event.ledger.ledger_id}</p>
          <p><span className="font-medium">Name:</span> {event.ledger.name}</p>
          <p><span className="font-medium">Description:</span> {event.ledger.description}</p>
          {event.ledger.r_currency && (
            <p>
              <span className="font-medium">Currency:</span> {event.ledger.r_currency.currency_code} 
              (Scale: {event.ledger.r_currency.scale})
            </p>
          )}
        </div>
      ) : 'N/A'
    }
  ];

  // Define children sections (tables)
  const childrenSections = [];

  // Add transfers section if available
  if (event.transfers && event.transfers.length > 0) {
    childrenSections.push({
      label: 'Transfers',
      content: (
        <DataTableSection
          data={event.transfers}
          title="Transfers"
          columns={[
            {
              key: 'from_account',
              header: 'From Account',
              render: (transfer) => transfer.from_account?.name || transfer.from_account_id || 'N/A'
            },
            {
              key: 'to_account',
              header: 'To Account',
              render: (transfer) => transfer.to_account?.name || transfer.to_account_id || 'N/A'
            },
            {
              key: 'amount',
              header: 'Amount',
              render: (transfer) => transfer.amount || 'N/A'
            },
            {
              key: 'status',
              header: 'Status',
              render: (transfer) => transfer.status || 'N/A'
            }
          ]}
          emptyMessage="No transfers found"
        />
      )
    });
  }

  // Add accounts section if available
  if (event.accounts && Object.keys(event.accounts).length > 0) {
    // Convert accounts object to array for DataTableSection
    const accountsArray = Object.entries(event.accounts).map(([role, account]) => ({
      role,
      ...account
    }));

    childrenSections.push({
      label: 'Accounts',
      content: (
        <DataTableSection
          data={accountsArray}
          title="Accounts"
          columns={[
            {
              key: 'role',
              header: 'Role',
              cellClassName: 'font-medium text-gray-900'
            },
            {
              key: 'name',
              header: 'Account',
              render: (row) => `${row.name} (ID: ${row.account_extra_id})`
            },
            {
              key: 'account_code',
              header: 'Type',
              render: (row) => `${row.account_code?.type || 'N/A'}: ${row.account_code?.account_code || 'N/A'}`
            },
            {
              key: 'entity',
              header: 'Entity',
              render: (row) => row.entity?.name ? `${row.entity.name} ${row.entity?.entity_id ? `(ID: ${row.entity.entity_id})` : ''}` : 'N/A'
            }
          ]}
          emptyMessage="No accounts found"
        />
      )
    });
  }

  // Add metadata section if available
  if (event.metadata && Object.keys(event.metadata).length > 0) {
    // Convert metadata object to array for DataTableSection, excluding original_event_json
    const metadataArray = Object.entries(event.metadata)
      .filter(([key]) => key !== 'original_event_json')
      .map(([key, value]) => ({
        key,
        value: typeof value === 'object' ? JSON.stringify(value) : value.toString()
      }));

    childrenSections.push({
      label: 'Metadata',
      content: (
        <DataTableSection
          data={metadataArray}
          title="Metadata"
          columns={[
            {
              key: 'key',
              header: 'Key',
              cellClassName: 'font-medium text-gray-900'
            },
            {
              key: 'value',
              header: 'Value',
              cellClassName: 'whitespace-normal text-gray-500'
            }
          ]}
          emptyMessage="No metadata found"
        />
      )
    });
  }

  return (
    <GenericDetailView
      data={event}
      title="Processed Event Detail"
      subtitle={`Event ID: ${event.event_id}`}
      sections={basicSections}
      childrenSections={childrenSections}
      onBack={onBack}
      onViewJson={onViewJson}
      customActions={customActions}
    />
  );
};

export default ProcessedEventDetail;
File: ./src/components/processed-events/ProcessedEventsView.js
--------------------
import React, { useState, useEffect } from 'react';
import { LoadingSpinner, ErrorAlert } from '../common';
import ProcessedEventsList from './ProcessedEventsList';
import ProcessedEventDetail from './ProcessedEventDetail';
import apiService from '../../services/apiService';

/**
 * Main component for the Processed Events tab
 */
const ProcessedEventsView = ({ onViewJson }) => {
  const [events, setEvents] = useState([]);
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [view, setView] = useState('list'); // 'list' or 'detail'
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // Fetch processed events on component mount
  useEffect(() => {
    fetchProcessedEvents();
  }, []);

  // Fetch processed events from the API
  const fetchProcessedEvents = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const data = await apiService.transaction.getProcessedEvents();
      setEvents(data);
      setIsLoading(false);
    } catch (err) {
      console.error('Error fetching processed events:', err);
      setError(err.message || 'An error occurred while fetching processed events');
      setIsLoading(false);
    }
  };

  // Handle event selection
  const handleSelectEvent = (event) => {
    setSelectedEvent(event);
    setView('detail');
  };

  // Handle back button click
  const handleBack = () => {
    setSelectedEvent(null);
    setView('list');
  };

  // Error state
  if (error) {
    return (
      <div className="mb-6">
        <ErrorAlert 
          error={error} 
          onRetry={fetchProcessedEvents} 
        />
      </div>
    );
  }

  return (
    <div>
      {view === 'list' && (
        <ProcessedEventsList 
          events={events}
          onSelectEvent={handleSelectEvent}
          onViewJson={onViewJson}
          onRefresh={fetchProcessedEvents}
          loading={isLoading}
        />
      )}
      
      {view === 'detail' && selectedEvent && (
        <ProcessedEventDetail 
          event={selectedEvent}
          onBack={handleBack}
          onViewJson={onViewJson}
        />
      )}
    </div>
  );
};

export default ProcessedEventsView;
File: ./src/components/processed-events/ProcessedEventsList.js
--------------------
import React from 'react';
import { GenericListView, ProcessedEventConfig } from '../common';

/**
 * Component to display a list of processed events using GenericListView
 */
const ProcessedEventsList = ({ events, onSelectEvent, onViewJson, onRefresh, loading }) => {
  // Define custom columns that extend the base configuration
  const columns = [
    ...ProcessedEventConfig.listColumns,
    {
      key: 'metadata',
      header: 'Metadata',
      cellClassName: 'text-gray-500',
      render: (event) => {
        if (!event.metadata || Object.keys(event.metadata).length === 0) {
          return null;
        }
        
        return (
          <div className="flex flex-wrap">
            {Object.entries(event.metadata).map(([key, value], index) => (
              <span
                key={index}
                className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800 mr-2 mb-1"
              >
                {key}: {typeof value === 'object' ? JSON.stringify(value) : value.toString()}
              </span>
            ))}
          </div>
        );
      }
    }
  ];

  return (
    <GenericListView
      data={events}
      columns={columns}
      title="Processed Events"
      idField={ProcessedEventConfig.idField}
      loading={loading}
      onItemClick={onSelectEvent}
      onViewJson={onViewJson}
      onRefresh={onRefresh}
      searchPlaceholder="Search processed events..."
      emptyMessage="No processed events found"
    />
  );
};

export default ProcessedEventsList;
File: ./src/index.js
--------------------
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
File: ./tailwind.config.js
--------------------
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
